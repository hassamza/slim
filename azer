/ *! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
// @ sourceMappingURL = jquery-1.10.2.min.map
* /
(fonction (e, t) {var n, r, i = type de t, o = e.location, a = e.document, s = a.documentElement, l = e.jQuery, u = e. $, c = {}, p = [], f = "1.10.2", d = p.concat, h = p.push, g = p.slice, m = p.indexOf, y = c.toString, v = c. hasOwnProperty, b = f.trim, x = fonction (e, t) {return new x.fn.init (e, t, r)}, w = / [+ -]? (?: \ d * \. | ) \ d + (?: [eE] [+ -]? \ d + |) /. source, T = / \ S + / g, C = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, N = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, k = / ^ <(\ w +) \ s * \ /?> (?: <\ / \ 1> |) $ /, E = / ^ [\],: {} \ s] * $ /, S = / (? : ^ |: |,) (?: \ s * \ [) + / g, A = / \\ (?: ["\\\ / bfnrt] | u [\ da-fA-F] {4}) /g,j=/"[\"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]? \ d + |) / g, D = / ^ - ms - /, L = / - ([\ da-z]) / gi, H = fonction (e, t) {return t.toUpperCase ()}, q = function (e) {(a.addEventListener || "load" === e.type || "complète" === a.readyState) && (_ (), x.ready ())}, _ = fonction ( ) {a.addEventListener? (a.removeEventListener ("DOMContentLoaded", q,! 1), e.removeEventListener ("charger", q,! 1)) :( a.detachEvent ("onreadystatechange", q), e.detachEvent ("onload", q)) }; x.fn = x.prototype = {jquery: f, constructeur: x, init: fonction (e, n, r) {var i, o; si (! e) renvoie ceci; if ("string" == typeof e) {if (i = "<" === e.charAt (0) && ">" === e.charAt (e.length-1) && e.length> = 3? [null, e, null ]: N.exec (e),! I ||! I [1] && n) renvoie! N || n.jquery? (N || r) .find (e): this.constructeur (n) .find ( e); if (i [1]) {if (n = n instance de x? n [0]: n, x.merge (this, x.parseHTML (i [1], n && n.nodeType? n.ownerDocument || n: a,! 0)), k.test (i [1]) && x.isPlainObject (n)) pour (i dans n) x.isFunction (this [i])? this [i] (n [i] ): this.attr (i, n [i]); renvoyer this} si (o = a.getElementById (i [2]), o && o.parentNode) {if (o.id! == i [2]) retourner r.find (e); this.length = 1,this [0] = o} renvoie this.context = a, this.selector = e, ceci} retourne e.nodeType? (this.context = this [0] = e, this.length = 1, this): x. isFunction (e)? r.ready (e) :( e.selector! == t && (this.selector = e.selector, this.context = e.context), x.makeArray (e, this))}, selecteur : "", longueur: 0, toArray: function () {return g.call (this)}, obtenez: function (e) {return null == e? this.toArray (): 0> e? this [this. length + e]: this [e]}, pushStack: fonction (e) {var t = x.merge (this.constructeur (), e); return t.prevObject = ceci, t.context = this.context, t }, chaque: fonction (e, t) {return x.each (ceci, e, t)}, prêt: function (e) {return x.ready.promise (). done (e), this}, tranche: function () {return this.pushStack (g.apply (this, arguments))}, d'abord: function () {return this.eq (0)}, last: function () {return this.eq (-1)} , eq: function (e) {var t = cette.longueur, n = + e + (0> e? t: 0); return this.pushStack (n> = 0 && t> n? [this [n]]: [] )},carte:function (e) {retourne this.pushStack (x.map (this, fonction (t, n) {retourne e.call (t, n, t)})}, end: function () {retourne this.prevObject | | this.constructor (null)}, appuyez sur: h, sorte: []. sort, splice: []. splice}, x.fn.init.prototype = x.fn, x.extend = x.fn.extend = function () {var e, n, r, i, o, a, s = arguments [0] || {}, l = 1, u = arguments.length, c =! 1; pour ("booléen" == typeof s && (c = s, s = arguments [1] || {}, l = 2), "objet" == typeof s || x.isFonction (s) || (s = {}), u == = l && (s = ceci, - l); u> l; l ++) if (null! = (o = arguments [l])) pour (i dans o) e = s [i], r = o [i ], s! == r && (c && r && (x.isPlainObject (r) || (n = x.isArray (r)))? (n? (n =! 1, a = e && x.isArray (e)? e: []): a = e && x.isPlainObject (e)? e: {}, s [i] = x.extend (c, a, r)): r! == t && (s [i] = r)); return s}, x.extend ({expando: "jQuery" + (f + Math.random ()). replace (/ \ D / g, ""), noConflict: fonction (t) {return e. $ == = x && (e. $ = u), t && e.jQuery === x && (e.jQuery = l), x}, isReady:! 1, readyWait: 1, holdReady: fonction (e) {e? x.readyWait ++: x .ready (! 0)}, ready: function (e) {if (e ===! 0?! - x.readyWait:! x.isReady) {if (! a.body) retourne setTimeout (x.ready ); x.isReady =! 0, e! ==! 0 && - x.readyAttendre> 0 || (n.résolveWith (a, [x]), x.fn.trigger && x (a) .trigger ("prêt" ) .off ("ready"))}}, isFonction: function (e) {return "fonction" === x.type (e)}, isArray: Array.isArray || fonction (e) {return "tableau" === x.type (e)}, isWindow: fonction (e) {return null! = e && e == e.window}, isNumeric: function (e) {return! estNaN (parseFloat (e)) && isFinite (e) }, tapez: function (e) {return null == e? e + "": "objet" == typeof e || "fonction" == typeof e? c [y.call (e)] || "objet" : typeof e}, isPlainObject: fonction (e) {var n; si (! e || "objet"! == x.tapez (e) || e.nodeType || x.isWindow (e)) return! 1; essayez {if (e.constructor &&! v.call (e, "constructeur") &&! v.call (e.constructor. prototype, "isPrototypeOf")) return! 1} catch (r) {return! 1} if (x.support.ownLast) pour (n dans e) return v.call (e, n); for (n dans e) ; return n === t || v.call (e, n)}, isEmptyObject: fonction (e) {var t; pour (t dans e) return! 1; return! 0}, erreur: function (e) {throw Erreur (e)}, parseHTML: fonction (e, t, n) {if (! e || "chaîne"! = typeof e) renvoie null; "booléen" == typeof t && (n = t, t = ! 1), t = t || a; var r = k.exec (e), i =! N && []; renvoyer r? [T.createElement (r [1])] :( r = x.buildFragment ( [e], t, i), i && x (i) .remove (), x.merge ([], r.childNodes)), parseJSON: fonction (n) {return e.JSON && e.JSON.parse? e. JSON.parse (n): null === n? N: "chaîne" == typeof n && (n = x.trim (n), n && E.test (n.replace (A, "@"). Remplacer (j ,"]"). replace (S, "")))? Fonction ("return" + n) () :( x.error ("JSON invalide:" + n), t)}, parseXML: fonction (n) {var r, i; if (! n || "chaîne"! = typeof n) retourne null; essaye {e.DOMParser? (i = nouveau DOMParser, r = i.parseFromString (n, "text / xml")) : (r = new ActiveXObject ("Microsoft.XMLDOM"), r.async = "faux", r.loadXML (n))} catch (o) {r = t} renvoie r && r.documentElement &&! rEgetElementsByTagName ("parsererror" ") .length || x.error (" XML invalide: "+ n), r}, noop: function () {}, globalEval: fonction (t) {t && x.trim (t) && (e.execScript || function (t) {e.eval.call (e, t)}) (t)}, camelCase: function (e) {retourne e.replace (D, "ms -"). replace (L, H)}, nodeName: function (e, t) {Renvoie e.nodeName && e.nodeName.toLowCase () === t.toLowCase ()}, chaque: fonction (e, t, n) {var r, i = 0, o = e .length, a = M (e);if (n) {if (a) {pour (; o> i; i ++) si (r = t.apply (e [i], n), r ===! 1) break} else pour (i dans e ) si (r = t.apply (e [i], n), r ===! 1) break} else si (a) {pour (; o> i; i ++) si (r = t.call (e [i], i, e [i]), r ===! 1) break} else pour (i dans e) if (r = tappel (e [i], i, e [i]), r ===! 1) break; return e}, trim: b &&! B.call ("\ ufeff \ u00a0")? Function (e) {return null == e? "": B.call (e)}: function (e) {return null == e? "" :( e + ""). replace (C, "")}, makeArray: fonction (e, t) {var n = t || []; return null! = e && (M (Objet (e))? x.merge (n, "chaîne" == typeof e? [e]: e): h.call (n, e)), n}, inArray: fonction (e , t, n) {var r; if (t) {if (m) renvoie m.call (t, e, n); pour (r = t.length, n = n? 0> n? Math.max ( 0, r + n): n: 0; r> n; n ++) if (n dans t && t [n] === e) return n} return-1}, fusionner: function (e, n) {var r = n.length, i = e.length, o = 0; if ("nombre" == typeof r) pour (; r> o; o ++) e [i ++] = n [o]; sinon while (n [o] !== t) e [i ++] = n [o ++]; return e.length = i, e}, grep: fonction (e, t, n) {var r, i = [], o = 0, a = e .length; pour (n = !! n; a> o; o ++) r = !! t (e [o], o), n! == r && i.push (e [o]); retour i}, carte : fonction (e, t, n) {var r, i = 0, o = e.longueur, a = M (e), s = []; si (a) pour (; o> i; i ++) r = t (e [i], i, n), null! = r && (s [s.length] = r), sinon pour (i dans e) r = t (e [i], i, n), null! = r && (s [s.length] = r); return d.apply ([], s)}, guid: 1, proxy: fonction (e, n) {var r, i, o; return "chaîne" = = typeof n && (o = e [n], n = e, e = o), x.isFonction (e)? (r = g.call (arguments, 2), i = fonction () {return e.apply ( n || this, r.concat (g.call (arguments))}, i.guid = e.guid = e.guid || x.guid ++, i): t}, accès: fonction (e, n, r, i, o, a, s) {var l = 0, u = e.length, c = null == r; if ("objet" === x.type (r)) {o =! 0; pour (l dans r) x.access (e, n, l, r [l],! 0, a, s)} sinon if (i! == t && (o =! 0, x.isFonction (i) | | (s =! 0), c && (s? (n.call (e, i), n = null) :( c = n, n = fonction (e, t,n) {return c.call (x (e), n)})), n)) pour (; u> l; l ++) n (e [l], r, s? i: i.call (e [ l], l, n (e [l], r))); return o? e: c? n.call (e): u? n (e [0], r): a}, maintenant: function ( ) {return (nouvelle date) .getTime ()}, swap: fonction (e, t, n, r) {var i, o, a = {}; pour (o en t) a [o] = e.style [o], e.style [o] = t [o]; i = n.applique (e, r || []); pour (o dans t) e.style [o] = a [o]; i}}), x.ready.promise = fonction (t) {if (! n) si (n = x.Deferred (), "complet" === a.readyState) setTimeout (x.ready); (a.addEventListener) a.addEventListener ("DOMContentLoaded", q,! 1), e.addEventListener ("charger", q,! 1); else {a.attachEvent ("onreadystatechange", q), e.attachEvent ( "onload", q); var r =! 1; essayez {r = null == e.frameElement && un.documentElement} catch (i) {} r && r.doScroll && fonction o () {if (! x.isReady) {try {r .doScroll ("left")} catch (e) {return setTimeout (o, 50)} _ (), x.ready ()}} ()} renvoie n.promise (t)}, x.each ("Booléen Nombre Chaîne Fonction Tableau Date RegExp Objet Erreur" .split (""), fonction (e, t) {c ["[objet" + t + "]"] = t. toLowerCase ()}); fonction M (e) {var t = e.length, n = x.type (e); return x.isWindow (e) ?! 1: 1 === e.nodeType && t?! 0: "array" === n || "fonction"! == n && (0 === t || "nombre" == typeof t && t> 0 && t-1 dans e)} r = x (a), fonction (e, t) {var n, r, i, o, a, s, l, u, c, p, f, d, h, g, m, y, v, b = "sizzle" + - nouvelle date, w = e.document, T = 0, C = 0, N = st (), k = st (), E = st (), S =! 1, A = fonction (e, t) {return e === t ? (S =! 0,0): 0}, j = type de t, D = 1 << 31, L = {}. HasOwnProperty, H = [], q = H.pop, _ = H.push, M = H.push, O = H.slice, F = H.indexOf || fonction (e) {var t = 0, n = cette.longueur; pour (; n> t; t ++) if (this [t] = == e) renvoie t, return-1}, B = "checked | selected | async | autofocus | autoplay | controls | defer | disabled | caché | ismap | loop | multiple | ouvert | readonly | required | scoped ", P =" [\\ x20 \\ t \\ r \\ n \ \ f] ", R =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", W = R.réplace (" w "," w # "), $ =" \\ ["+ P +" * "(" + R + ")" + P + "* (?: ([* ^ $ |! ~]? =)" + P + "* (? :( ['\ "]) ((?: \\\\. | [^ \\\\]) *?) \\ 3 | (" + W + ") |) |)" + P + "* \\]" , I = ":(" + R + ") (?: \\ (((['\"]) ((?: \\\\. | [^ \\\\]) *?) \\ 3 | ((?: \\\\. | [^ \\\\ () [\\]] | "+ $. replace (3,8) +") *) |) *) \\) |) ", z = RegExp ("^" + P + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + P + "+ $", "g"), X = RegExp ("^" + P + "*," + P + "*"), U = RegExp ("^" + P + "* ([> + ~] |" + P + ")" + P + "*") , V = RegExp (P + "* [+ ~]"), Y = RegExp ("= "+ P +" * ([^ \\] '\ "] *)" + P + "* \\]", "g"), J = RegExp (I), G = RegExp ("^" + W + " $ "), Q = {ID: RegExp (" ^ # ("+ R +") "), CLASSE: RegExp (" ^ \\. ("+ R +") "), TAG: RegExp (" ^ ("+ R.replace ("w", "w *") + ")"), ATTR: RegExp ("^" + $), PSEUDO: RegExp ("^" + I), CHILD: RegExp ("^ :( seulement | premier | dernier | nième | nième-dernier) - (enfant | de-type) (?: \\ ("+ P +" * (pair | impair | (([+ -] |) (\\ d *) n |) "+ P +" * (?: ([+ -] |) "+ P +" * (\\ d +) |)) "+ P +" * \\) |) ", bool: RegExp ("^ (?:" + B + ") $", "i"), needsContext: RegExp ("^" + P + "* [> + ~] |: (pair | impair | eq | gt | lt | nth | premier | dernier) (?: \\ ("+ P +" * ((?: - \\ d)? \\ d *) "+ P +" * \\) |) (? = [^ -] | $) "," i ")}, K = / ^ [^ {] + \ {\ s * \ [natif \ w /, Z = / ^ (?:# ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, et = / ^ (?: entrée | sélectionner | textarea | bouton) $ / i, tt = / ^ h \ d $ / i, nt = / '| \\ / g, rt = RegExp ("\\\\ ([\\ da-f] {1,6}" + P + "? | (" + P + ") |.)", "Ig"), il = fonction (e, t, n) {var r = "0x" + t-65536; return r! == r || n? T: 0> r ? String.fromCharCode (r + 65536): String.fromCharCode (55296 | r >> 10,56320 | 1023 & r)}; try {M.application (H = O.call (w.childNodes), w.childNodes), H [w.childNodes.length] .nodeType} catch (ot) {M = {applique: H.length? function (e, t) {_. apply (e, Oappel (t))}: fonction (e, t) {var n = e.length, r = 0, tandis que (e [n ++] = t [r ++]); e.length = n-1}}} fonction de (e, t, n, i) {var o, a, s, l, u, c, d, m, y, x; si ((t? t.ownerDocument || t: w)! == f && p (t), t = t || f, n = n || [],! e || "chaîne"! = typeof e) renvoie n; if (1! == (l = t.nodeType) && 9! == l) renvoie []; if (h &&! i ) {if (o = Z.exec (e)) si (s = o [1]) {if (9 === l) {if (a = t.getElementById (s),! a ||! a.parentNode) return n; if (a.id === s) renvoie n.push (a), n} else if (t.ownerDocument && (a = t.propriétaire.getElementById (s)) && v (t, a) && a .id === s) renvoie n.push (a), n} else {if (o [2]) renvoie M.apply (n, t.getElementsByTagName (e)), n; si ((s = o [ 3]) && r.getElementsByClassName && t.getElementsByClassName) renvoie M.apply (n, t.getElementsByClassName (s)), n} if (r.qsa && (! G ||! G.test (e))) {if (m = d = b, y = t, x = 9 === l && e, 1 === l && "objet"! == t.nodeName.toLongueCase ()) {c = mt (e), (d = t.getAttribute ( "id"))? m = d.replace (nt, "\\ $ &"): t.setAttribute ("id", m), m = "[id = '" + m + "']", u = c.length; while (u -) c [u] = m + yt (c [u]); y = V.test (e) && t.parentNode || t, x = c.join (",") } if (x) try {retourne M.apply (n, y.querySelectorAll (x)), n} catch (T) {} finally {d || t.removeAttribute ("id"}}}} renvoie kt (e.replace (z, "$ 1"), t, n, i)} fonction st () {var e = []; fonction t (n, r) {return e.push (n + = "")> o.cacheLength && supprimer t [e.shift ()], t [n] = r} return t} fonction lt (e) {return e [b] =! 0, e} fonction ut (e) { var t = f.createElement ("div"); essayez {return !! e (t)} catch (n) {return! 1} enfin {t.parentNode && t.parentNode.removeChild (t), t = null}} fonction ct (e, t) {var n = e.split ("|"), r = e.length; tandis que (r -) o.attrHandle [n [r]] = t} fonction pt (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && (~ tsourceIndex || D) - (~ eSourceIndex || D); if (r) renvoie r; if ( n) while (n = n.nextSibling) if (n === t) return-1; return e? 1: -1} fonction ft (e) {return function (t) {var n = t.nodeName.toLowerCase (); return "entrée" === n && t.type === e}} fonction dt (e) {fonction de retour (t) {var n = t.nodeName.toLowerCase (); return ("input "=== n ||" bouton "=== n) && t.type === e}} fonction ht (e) {return lt (fonction (t) {return t = + t, lt (fonction (n , r) {var i, o = e ([], longueur n, t), a = o.length; tandis que (a -) n [i = o [a]] && (n [i] =! (r [i] = n [i]))})})} s = at.isXML = fonction (e) {var t = e && (e.ownerDocument || e) .documentElement; return t "" HTML "! == t.nodeName:! 1}, r = at.support = {}, p = at.setDocument = fonction (e) {var n = e? e.propriétaire? || e: w, i = n.defaultView; return n! == f && 9 === n.nodeType && n.documentElement? (f = n, d = n.documentElement, h =! s (n), i && i.attachEvent && i! == i.top && i.attachEvent ("onbeforeunload", function () {p ()}), r.attributes = ut (fonction (e) {retourne e.className = "i",! e.getAttribute ("className")}), r.getElementsByTagName = ut (fonction ( e) {return e.appendChild (n.createComment ("")),! e.getElementsByTagName ("* "). length}), r.getElementsByClassName = ut (fonction (e) {return e.innerHTML =" <div class = 'a'> </ div> <div class = 'a i'> </ div> ", e.firstChild.className =" i ", 2 === e.getElementsByClassName (" i "). longueur}), r.getById = ut (fonction (e) {return d.appendChild (e) .id = b,! n.getElementsByName ||! n.getElementsByName (b) .length}), r.getById? (o.find.ID = fonction (e, t) {if (type de t.getElementById! == j && h) { var n = t.getElementById (e); renvoie n && n.parentNode? [n]: []}}, o.filter.ID = fonction (e) {var t = e.replace (rt, it); fonction de retour ( e) {return e.getAttribute ("id") === t}}) :( supprimer o.find.ID, o.filter.ID = fonction (e) {var t = e.replace (rt, it) ; return function (e) {var n = type de e.getAttributeNode! == j && e.getAttributeNode ("id"); return n && n.value === t}}), o.find.TAG = r.getElementsByTagName? function (e, n) {return type de n.getElementsByTagName! == j? n.getElementsByTagName (e): t}: fonction (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++]) 1 === n.nodeType && r.push (n); return r} return o}, o.find .CLASS = r.getElementsByClassName && (e, n) {return type de n.getElementsByClassName! == j && h? N.getElementsByClassName (e): t}, m = [], g = [], (r.qsa = K.test (n.querySelectorAll)) && (ut (fonction (e) {e.innerHTML = "<select> <option sélectionnée = ''> </ option> </ select>", e.querySelectorAll ("[selected]") .length || g.push ("\\ [" + P + "* (?: valeur |" + B + ")"), e.querySelectorAll (": checked"). longueur || g.push (": cochée ")}), ut (fonction (e) {var t = n.createElement (" entrée "); t.setAttribute (" type ","hidden"), e.appendChild (t) .setAttribute ("t", ""), e.querySelectorAll ("[t ^ = '']"). longueur && g.push ("[* ^ $] =" + P + "* (?: '' | \" \ ")"), e.querySelectorAll (": activé"). Longueur || g.push (": activé", ": désactivé"), e.querySelectorAll (" * ,: x "), g.push (",. *: ")})), (r.matchesSelector = K.test (y = d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d. msMatchesSelector)) && ut (fonction (e) {r.disconnectedMatch = y.call (e, "div"), y.call (e, "[s! = '']: x"), m.push ("! = ", I)}), g = g.length && RegExp (g.join (" | ")), m = m.length && RegExp (m.join (" | ")), v = K.test (d.contains) || d.compareDocumentPosition? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e, r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? ncontient (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r)))}: function (e, t) {if (t) while (t = t.parentNode) si (t === e) return! 0; return! 1}, A = d.compareDocumentPosition? function (e, t) {si (e === t) retourner S =! 0,0; var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition (t); retourner i? 1 & i ||! r.sortDetached && t.compareDocumentPosition (e) === i? e === n || v (w, e)? - 1: t === n || v (w, t)? 1: c? F.call (c, e) -F.call (c, t ): 0: 4 & i? -1: 1: e.compareDocumentPosition? -1: 1}: fonction (e, t) {var r, i = 0, o = e.parentNode, a = t.parentNode, s = [ e], l = [t]; si (e === t) renvoie S =! 0,0; si (! o || a) renvoie e === n? -1: t === n? 1: o? -1: a? 1: c? F.call (c, e) -F.call (c, t): 0; si (o === a) renvoie pt (e, t); r = e; while (r = r.parentNode) s.unshift (r); r = t; tandis que (r = r.parentNode) l.unshift (r); tandis que (s [i] === l [i] ) i ++;retourne i? pt (s [i], l [i]): s [i] === w? -1: l [i] === w? 1: 0}, n): f}, at. correspond à = function (e, t) {return à (e, null, null, t)}, à.matchesSelector = fonction (e, t) {if ((e.ownerDocument || e)! == f && p (e) , t = t.replace (Y, "= '$ 1']"),! (! r.matchesSelector ||! h || m && m.test (t) || g && g.test (t))) try {var n = y.call (e, t); if (n || r.disconnectedMatch || e.document && 11! == e.document.nodeType) return n} catch (i) {} return à (t, f, null, [e]). longueur> 0}, at.contains = fonction (e, t) {return (e.ownerDocument || e)! == f && p (e), v (e, t)}, at.attr = function (e, n) {(e.ownerDocument || e)! == f && p (e); var i = o.attrHandle [n.toLongueCase ()], a = i && L.call (o.attrHandle, n.toLowerCase ())? i (e, n,! h): t; renvoie a === t? r.attributs ||! h? e.getAttribute (n) :( a = e.getAttributeNode (n)) && a. a.value: null: a}, at.error = fonction (e) {throw Erreur ("Erreur de syntaxe,expression non reconnue: "+ e)}, at.uniqueSort = fonction (e) {var t, n = [], i = 0, o = 0; si (S =! r.detectDuplicates, c =! r.sortStable && e. tranche (0), e.sort (A), S) {tandis que (t = e [o ++]) t === e [o] && (i = n.push (o)), tandis que (i--) e.splice (n [i], 1)} renvoie e}, a = at.getText = fonction (e) {var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) {if ("chaîne" == typeof e.textContent) retourne e.textContent; pour (e = e.firstChild; e; e = e.nextSibling) n + = a (e)} sinon if (3 === i || 4 === i) renvoie e.nodeValue} else pour (; t = e [r]; r ++) n + = a (t); return n}, o = at.selectors = {longueurCache: 50, createPseudo: lt, correspondance: Q, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode" , d'abord:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", d'abord:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {return e [1] = e [1].remplacer (rt, it), e [3] = (e [4] || e [5] || ""). remplacer (rt, it), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)}, CHILD: fonction (e) {return e [1] = e [1] .toLongueCase (), "nième "=== e [1] .slice (0,3)? (e [3] || at.erreur (e [0]), e [4] = + (e [4]? e [5] + (e [6] || 1): 2 * ("pair" === e [3] || "impair" === e [3])), e [5] = + (e [7] + e [8] || "impair" === e [3])): e [3] && at.erreur (e [0]), e}, PSEUDO: fonction (e) {var n, r =! e [5] && e [2]; return Q.CHILD.test (e [0])? Null: (e [3] && e [4]! == t? E [2] = e [4]: ​​r && J.test (r) && (n = mt (r,! 0)) && (n = r.indexOf (")", r.length-n) -r.length) && (e [0] = e [0]. tranche (0, n), e [2] = r.slice (0, n)), e.slice (0,3))}}, filtre: {TAG: fonction (e) {var t = e.replace (rt, it) .toLowerCase (); return "*" === e? function () {return! 0}: fonction (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: fonction (e) {var t = N [e + ""]; renvoie t || (t = RegExp ("(^ |" + P + ")" + e + "( "+ P +" | $) ")) && N (e, fonction (e) {return t.test (" chaîne "== typeof e.className && e.className || typeof e.getAttribute! == j && e.getAttribute (" classe ") ||" ")})}, ATTR: fonction (e, t, n) {fonction de retour (r) {var i = at.attr (r, e); retour null == i?"! = " === t: t? (i + = "", "=" === t? i === n: "! =" === t? i! == n: "^ =" === t ? n && 0 === i.indexOf (n): "* =" === t & n && i.indexOf (n)> - 1: "$ =" === t & n && i.slice (-n.length) = == n: "~ =" === t? ("" + i + "") .indexOf (n)> - 1: "| =" === t? i === n || i.slice ( 0, n.length + 1) === n + "-":! 1):! 0}}, CHILD: fonction (e, t, n, r, i) {var o = "nième"! == e .slice (0,3),a = "dernier"! == e.slice (-4), s = "de-type" === t; return 1 === r && 0 === i? fonction (e) {return !! e.parentNode }: function (t, n, l) {var, c, p, f, d, h, g = o! == a? "nextSibling": "previousSibling", m = t.parentNode, y = s && t. nodeName.toLowerCase (), v =! l &&! s; if (m) {si (o) {while (g) {p = t; tandis que (p = p [g]) if (s? p.nodeName.toLowerCase () === y: 1 === p.nodeType) return! 1; h = g = "seulement" === e &&! h && "nextSibling"} return! 0} si (h = [a? m.firstChild : m.lastChild], a && v) {c = m [b] || (m [b] = {}), u = c [e] || [], d = u [0] === T && u [1 ], alors que (p = ++ d && p && )) if (1 === p.nodeType && ++ f && p === t) {c [e] = [T, d, f]; pause}} else if (v && (u = (t [b] || (t [b] = {})) [e]) && [0] === T) f = u [1], sinon alors (p = ++ d && p && p [g] || (f = d = 0) || h.pop ()) if ((s? p.nodeName.toLowerCase () === y: 1 === p.nodeType) && ++ f && (v && ((p [b] || (p [b] = { })) [e] = [T, f]), p === t)) break, return f- = i, f === r || 0 === f% r && f / r> = 0}} }, PSEUDO: la fonction (e, t) {var n, r = o.pseudos [e] || o.setFilters [e.toLowerCase ()] || at.error ("pseudo non supporté:" + e); r [b]? r (t): r.length> 1? (n = [e, e, "", t], o.setFilters.hasOwnProperty (e.toLowerCase ())? lt (fonction (e, n ) {var i, o = r (e, t), a = o.length; tandis que (a -) i = F.call (e, o [a]), e [i] =! (n [i ] = o [a])}): fonction (e) {return r (e, 0, n)}): r}}, pseudos: {not: lt (fonction (e) {var t = [], n = [], r = l (e.replace (z, "$ 1")); return r [b]? lt (fonction (e, t, n, i) {var o, a = r (e, null, i, []), s = e.length; while (s -) (o = a [s]) && (e [s] =! (t [s] = o))}): fonction (e, i, o) {return t [0] = e, r (t, nul, o, n),! n.pop ()}}), a: lt (fonction (e) {return function (t) {return à (e, t) .length> 0}}), contient:lt (function (e) {return la fonction (t) {return (t.textContent || t.innerText || a (t)). indexOf (e)> - 1}}), lang: lt (fonction (e)) {return G.test (e || ") || at.error (" lang non pris en charge: "+ e), e = e.replace (rt, it) .toLongueCase (), fonction (t) {var n; faire si (n = h? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) renvoie n = n.toLongueCase (), n === e || 0 = == n.indexOf (e + "-"); while ((t = t.parentNode) && 1 === t.nodeType); return! 1}}), cible: function (t) {var n = e.localisation && e .location.hash; return n && n.slice (1) === t.id}, root: fonction (e) {return e === d}, focus: fonction (e) {return e === f.activeElement && (! f.hasFocus || f.hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)}, activé: function (e) {return e.disabled ===! 1 }, désactivé: function (e) {return e.disabled ===! 0}, vérifié: function (e) {var t = e.nodeName.toLowerCase (); return "input "=== t && !! e.checked ||" option "=== t && !! e.selected}, sélectionné: function (e) {return e.parentNode && e.parentNode.selectedIndex, e.selected ===! 0}, vide: function (e) {pour (e = e.firstChild; e; e = e.nextSibling) if (e.NodeName> "@" || 3 === e.nodeType || 4 === e.nodeType) return! 1; return! 0}, parent: function (e) {return! o.pseudos.empty (e)}, en-tête: function (e) {return tt.test (e.nodeName)}, input: function (e) {return et.test (e.nodeName)}, bouton: function (e) {var t = e.nodeName.toLowCase (); return "entrée" === t && "button" === e.type || "button" === t}, texte: function (e) {var t; return "entrée" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("type")) || t.toLowerCase () === e.type)}, d'abord: ht (fonction () {return [0]}), last: ht (fonction (e, t) {return [t-1]}), eq:ht (fonction (e, t, n) {return [0> n? n + t: n]}), pair: ht (fonction (e, t) {var n = 0; pour (; t> n; n + = 2) e.push (n), return e}), impair: ht (fonction (e, t) {var n = 1; pour (; t> n; n + = 2) e.push (n); e}), lt: ht (fonction (e, t, n) {var r = 0> n? n + t: n; pour (; - r> = 0;) e.push (r); }), gt: ht (fonction (e, t, n) {var r = 0> n? n + t: n; pour (; t> ++ r;) e.push (r); return e}) }}, o.pseudos.nth = o.pseudos.eq; pour (n dans {radio:! 0, case à cocher:! 0, fichier:! 0, mot de passe:! 0, image:! 0}) o.pseudos [ n] = ft (n); pour (n dans {soumettre:! 0, réinitialiser:! 0}) o.pseudos [n] = dt (n); fonction gt () {} gt.prototype = o.filters = o.pseudos, o.setFilters = new gt; fonction mt (e, t) {var n, r, i, a, s, l, u, c = k [e + ""], si (c) renvoie t? 0: c.slice (0); s = e, l = [], u = o.preFilter; tandis que (s) {(! N || (r = X.exec (s))) && (r && (s = s.slice (r [0] .length) || s), l.push (i = [])), n =! 1, (r = U.exec (s)) && (n = r.shift (), i.push ({valeur: n, tapez: r [0] .replace (z, "")}), s = s.slice (n.longueur)); pour (a dans o.filter)! (r = Q [a] .exec (s)) || u [a] &&! (r = u [a] (r)) || (n = r.shift (), i.push ({valeur: n, tapez: a, correspond: r}), s = s.slice (n.length)), si (! n) break} retourne t? s.length : s? at.erreur (e): k (e, l) .slice (0)} fonction yt (e) {var t = 0, n = e.longueur, r = ""; pour (; n> t ; t ++) r + = e [t] .value; return r} fonction vt (e, t, n) {var r = t.dir, o = n && "parentNode" === r, a = C ++; return t. première fonction (t, n, i) {while (t = t [r]) if (1 === t.nodeType || o) retourne e (t, n, i)}: fonction (t, n, s) {var l, u, c, p = T + "" + a; si (s) {while (t = t [r]) si ((1 === t.nodeType || o) && e (t, n, s)) return! 0} else while (t = t [r]) if (1 === t.nodeType || o) si (c = t [b] || (t [b] = {} ), (u = c [r]) && u [0] === p) {si ((l = u [1]) ===! 0 || l === i) return l ===! 0 } else si (u = c [r] = [p], u [1] = e (t, n, s) || i, u [1] ===! 0) return! 0}} fonction bt ( e) {return e.length> 1? fonction (t, n, r) {var i = e.length; tandis que (i -) if (! e [i] (t, n, r)) renvoie! 1 ; return! 0}:e [0]} fonction xt (e, t, n, r, i) {var o, a = [], s = 0, l = e.length, u = null! = t; pour (; l> s ; s ++) (o = e [s]) && (! n || n (o, r, i)) && (a.push (o), u && t.push (s)); return a} fonction wt (e , t, n, r, i, o) {return r &&! r [b] && (r = wt (r)), i &&! i [b] && (i = wt (i, o)), lt (fonction (o, a, s, l) {var u, c, p, f = [], d = [], h = a.longueur, g = o || Nt (t || "*", s.nodeType ? [s]: s, []), m =! e ||! o && t? g: xt (g, f, e, s, l), y = n? i || (o? e: h || r)? []: a: m; si (n && n (m, y, s, l), r) {u = xt (y, d), r (u, [], s, l), c = u .length; while (c-) (p = u [c]) && (y [d [c]] =! (m [d [c]] = p))} if (o) {if (i | | e) {if (i) {u = [], c = y.length; tandis que (c -) (p = y [c]) && u.push (m [c] = p); i (nul, y = [], u, l)} c = y.length; tandis que (c-) (p = y [c]) && (u = i? F.call (o, p): f [c]) > -1 && (o [u] =! (A [u] = p))}} autre y = xt (y === a? Y.splice (h, y.length): y), i? I ( null, a, y, l): M.application (a, y)})} fonction Tt (e) {var t, n, r, i = e.length, a = o.relatif [e [0].type], s = a || o.relative [""], l = a? 1: 0, c = vt (fonction (e) {return e === t}, s,! 0), p = vt (function (e) {return F.call (t, e)> - 1}, s,! 0), f = [fonction (e, n, r) {return! a && (r || n! == u ) || ((t = n) .nodeType? c (e, n, r): p (e, n, r))}]; pour (; i> l; l ++) if (n = o.relatif [ e [l] .type]) f = [vt (bt (f), n)]; else {if (n = o.filter [e [l] .type] .apply (null, e [l] .matches ), n [b]) {pour (r = ++ l; i> r; r ++) si (o.relative [e [r] .type]) break, retourner wt (l> 1 && bt (f), l> 1 && yt (e.slice (0, l-1) .concat ({value: "" === e [l-2] .type? "*": ""})). Replace (z, "$ 1") , n, r> l && Tt (e.slice (l, r)), i> r && Tt (e = e.slice (r)), i> r && yt (e))} f.push (n)} return bt (f )} fonction Ct (e, t) {var n = 0, r = t.longueur> 0, a = e.longueur> 0, s = fonction (s, l, c, p, d) {var h, g , m, y = [], v = 0, b = "0", x = s && [], w = null! = d, C = u, N = s || a && o.find.TAG ("*", ré&& l.parentNode || l), k = T + = null == C? 1: Math.random () || .1; pour (w && (u = l! ​​== f && l, i = n); null! = ( h = N [b]); b ++) {si (a && h) {g = 0; tandis que (m = e [g ++]) si (m (h, l, c)) {p.push (h); w && (T = k, i = ++ n)} r && ((h =! m && h) && v -, s && x.push (h))} if (v + = b, r && b! == v) {g = 0; tandis que (m = t [g ++]) m (x, y, l, c), si (s) {si (v> 0) tandis que (b -) x [b] || y [b] || y [b] = q.call (p)); y = xt (y)} M.apply (p, y), w &&! s && y.length> 0 && v + t.length> 1 && at.uniqueSort (p)} return w && (T = k, u = C), x}; return rt (s): s} l = at.compile = fonction (e, t) {var n, r = [], i = [], o = E [e + ""]; si (! O) {t || (t = mt (e)), n = t.longueur; tandis que (n -) o = Tt (t [n]), o [ b]? r.push (o): i.push (o); o = E (e, Ct (i, r))} return o}; fonction Nt (e, t, n) {var r = 0, i = t.length; pour (; i> r; r ++) at (e, t [r], n); return n} fonction kt (e, t, n, i) {var a, s, u, c , p, f = mt (e); si (! i && 1 === f.length) {if (s = f [0] = f [0] .slice (0), s.length> 2 && "ID" === (u = s [0]) .type && r.getById && 9 === t. nodeType && h & re o.relative [s [1] .type]) {if (t = (o.find.ID (u.matches [0] .replace (rt, it), t) || []) [0] ,! t) renvoie n; e = e.slice (s.shift (). valeur.length)} a = Q.needsContext.test (e)? 0: s.length; while (a -) {if (u = s [a], o.relative [c = u.type]) break, si ((p = o.find [c]) && (i = p (u.matches [0] .replace (rt, it), V.test (s [0] .type) && t.parentNode || t))) {if (s.splice (a, 1), e = i.length && yt (s),! E) renvoie M.apply (n , i), n, break}}} return l (e, f) (i, t,! h, n, V.test (e)), n} r.sortStable = b.split (""). (A) .join ("") === b, r.detectDuplicates = S, p (), r.sortDetached = ut (fonction (e) {return 1 & e.compareDocumentPosition (f.createElement ("div"))} ), ut (fonction (e) {return e.innerHTML = "<a href='#'> </a>", "# "=== e.firstChild.getAttribute (" href ")}) || ct (" type | href | hauteur | largeur ", fonction (e, n, r) {return r? t: e.getAttribute (n , "type" === n.toLowerCase ()? 1: 2)}), r.attributes && ut (fonction (e) {return e.innerHTML = "<entrée />", e.firstChild.setAttribute ("valeur" , ""), "" === e.firstChild.getAttribute ("valeur")}) || ct ("valeur", fonction (e, n, r) {return r || "entrée"! == e .nodeName.toLowerCase ()? t: e.defaultValue}), ut (fonction (e) {return null == e.getAttribute ("désactivé")}) || ct (B, fonction (e, n, r) {var i; renvoie r? t: (i = e.getAttributeNode (n)) && i.specified? i.value: e [n] ===! 0? n.toLongueCase (): null}), x.find = at, x.expr = at.selectors, x.expr [":"] = x.expr.pseudos, x.unique = at.uniqueSort, x.text = at.getText, x.isXMLDoc = at.isXML, x.contains = at.contains} (e); var O = {};fonction F (e) {var t = O [e] = {}; renvoie x.each (e.match (T) || [], fonction (e, n) {t [n] =! 0}), t} x.Callbacks = fonction (e) {e = "chaîne" == typeof e? O [e] || F (e): x.extend ({}, e); var n, r, i, o , a, s, l = [], u =! e.once && [], c = fonction (t) {pour (r = e.memory && t, i =! 0, a = s || 0, s = 0, o = l.longueur, n = 0; l && o> a; a ++) si (l [a] .apply (t [0], t [1]) ===! 1 && e.stopOnFalse) {r =! 1; break} n =! 1, l && (u? u.length && (u.shift ()): r? l = []: p.disable ()), p = {add: function () {if (l) {var t = l.length; (fonction i (t) {x.each (t, fonction (t, n) {var r = x.type (n); "fonction" === r? e.unique && p. a (n) || l.push (n): n && n.length && "chaîne"! == r && i (n)})}) (arguments), n? o = l.length: r && (s = t, c ( r))} return this}, enlever: function () {return l && x.each (arguments, fonction (e, t) {var r; while ((r = x.inArray (t, l, r))> - 1 ) l.splice (r, 1), n ​​&& (o>= r && o -, a> = r && a -)}), this}, a: function (e) {return e? x.inArray (e, l)> - 1:! (! l ||! l.length )}, vide: function () {return l = [], o = 0, this}, désactive: function () {return l = u = r = t, this}, désactivé: function () {return! l} , lock: function () {return u = t, r || p.disable (), this}, verrouillé: function () {return! u}, fireWith: fonction (e, t) {return! l || i && ! u || (t = t || [], t = [e, t.slice? t.slice (): t], n? u.push (t): c (t)), this}, feu : function () {return p.fireWith (ceci, arguments), this}, virgué: function () {return !! i}}; return p}, x.extend ({Différé: function (e) {var t = [["resolve", "done", x.Callbacks ("une fois la mémoire"), "resolved"], ["reject", "fail", x.Callbacks ("une fois la mémoire"), "rejeté"], [ "notify", "progress", x.Callbacks ("memory")]], n = "en attente", r = {state: function () {return n},always: function () {return i.done (arguments) .fail (arguments), this}, alors: function () {var e = arguments; renvoie x.Deferred (fonction (n) {x.each (t, fonction (t, o) {var a = o [0], s = x.isFonction (e [t]) && e [t]; i [o [1]] (fonction () {var e = s && s.apply (this , arguments); e && x.isFonction (e.promise)? e.promise (). done (n.résolve) .fail (n.reject) .progress (n.notify): n [a + "Avec"] (this = == r? n.promise (): ceci, s? [e]: arguments)})}, e = null}). promise ()}, promesse: function (e) {return null! = e? x .extend (e, r): r}}, i = {}; retourne r.pipe = r.then, x.each (t, fonction (e, o) {var a = o [2], s = o [3]; r [o [1]] = a.add, s && a.add (fonction () {n = s}, t [1 ^ e] [2] .disable, t [2] [2] .lock ), i [o [0]] = fonction () {return i [o [0] + "Avec"] (ceci === i? r: ceci, arguments), ceci}, i [o [0] + "Avec"] = a.fireWith}), r.promise (i), e && e.call (i, i), i}, quand: fonction (e) {var t = 0, n = g.call (arguments) , r = n.length,i = 1! == r || e && x.isFonction (e.promise)? r: 0, o = 1 === i? e: x.Deferred (), a = fonction (e, t, n) {return function (r) {t [e] = ceci, n [e] = arguments.length> 1? g.call (arguments): r, n === s? o.notifyAvec (t, n): - i || o.résolveWith (t, n)}}, s, l, u; si (r> 1) pour (s = Array (r), l = Array (r), u = Array (r); r> t; t ++) n [t] && x.isFonction (n [t] .promise)? n [t] .promise (). done (a (t, u, n)). fail (o.rejet) .progress ( a (t, l, s)): - i; renvoie i || o.résolveWith (u, n), o.promise ()}}, x.support = fonction (t) {var n, r, o, s, l, u, c, p, f, d = un.createElement ("div"); if (d.setAttribute ("className", "t"), d.innerHTML = "<link /> < table> </ table> <a href='/a'> a </a> <type d'entrée = 'checkbox' /> ", n = d.getElementsByTagName (" * ") || [], r = d. getElementsByTagName ("a") [0],! r ||! r.style ||! n.length) retourne t; s = a.createElement ("select "), u = s.appendChild (a.createElement (" option ")), o = d.getElementsByTagName (" entrée ") [0], r.style.cssText =" top: 1px; float: left; opacity : .5 ", t.getSetAttribute =" t "! == d.className, t.leadingWhitespace = 3 === d.firstChild.nodeType, t.tbody =! D.getElementsByTagName (" tbody "). Longueur, t .htmlSerialize = !! d.getElementsByTagName ("link"). longueur, t.style = / top / .test (r.getAttribute ("style")), t.hrefNormalized = "/ a" === r.getAttribute ("href"), t.opacity = / ^ 0.5 / .test (r.style.opacity), t.cssFloat = !! r.style.cssFloat, t.checkOn = !! o.valeur, t.optSelected = u.selected, t.enctype = !! a.createElement ("formulaire"). enctype, t.html5Clone = "<: nav> </: nav>"! == a.createElement ("nav"). cloneNode ( ! 0) .outerHTML, t.inlineBlockNeedsLayout =! 1, t.shrinkWrapBlocks =! 1, t.pixelPosition =! 1, t.deleteExpando =! 0, t.noCloneEvent =! 0, t.reliableMarginRight =! 0, t.boxSizingReliable =! 0, o.checked =! 0, t.noCloneChecked = o.cloneNode (! 0) .checked, s.disabled =! 0, t.optDisabled =! U.disabled, essayez {delete d.test} catch (h) {t.deleteExpando =! 1} o = a.createElement ("entrée"), o.setAttribute ("valeur" , ""), t.input = "" === o.getAttribute ("valeur"), o.value = "t", o.setAttribute ("type", "radio"), t.radioValue = "t "=== o.value, o.setAttribute (" vérifié "," t "), o.setAttribute (" nom "," t "), l = a.createDocumentFragment (), l.appendChild (o), t .appendChecked = o.checked, t.checkClone = l.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, d.attachEvent && (d.attachEvénement ("onclick", function () {t.noCloneEvent =! 1}), d.cloneNode (! 0) .click ()); for (f dans {submit:! 0, changez:! 0, focusin :!0}) d.setAttribute (c = "on" + f, "t"), t [f + "Bulles"] = c dans e || d.attributes [c] .expando ===! 1; d.style .backgroundClip = "boîte de contenu", d.cloneNode (! 0) .style.backgroundClip = "", t.clearCloneStyle = "boîte de contenu" === d.style.backgroundClip; pour (f dans x (t) ) break; return t.ownLast = "0"! == f, x (fonction () {var n, r, o, s = "remplissage: 0; marge: 0; bordure: 0; affichage: bloc; taille: boîte de contenu; -moz-boîte-taille: boîte de contenu; -webkit-boîte-taille: boîte de contenu; ", l = a.getElementsByTagName (" corps ") [0]; l && (n = a. createElement ("div"), n.style.cssText = "bordure: 0; largeur: 0; hauteur: 0; position: absolue; haut: 0; gauche: -9999px; marge-dessus: 1px", l.appendChild ( n) .appendChild (d), d.innerHTML = "<table> <tr> <td> </ td> <td> t </ td> </ tr> </ table>", o = d.getElementsByTagName ("td"), o [0] .style.cssText = "remplissage: 0; marge: 0; bordure: 0; affichage: aucun", p = 0 === o [0] .offsetHeight, o [0 ] .style.display = "", o [1] .style.display = "aucun", t.reliableHiddenOffsets = p && 0 === o [0] .offsetHeight, d.innerHTML = "", d.style.cssText = "box-sizing: border-box; -moz-box-taille: border-box; -webkit-box-taille: border-box; remplissage: 1px; border: 1px; affichage: block; largeur: 4px; margin-top : 1%; position: absolue; top: 1%; ", x.swap (l, null! = L.style.zoom? {Zoom: 1}: {}, fonction () {t.boxSizing = 4 == = d.offsetWidth}), e.getComputedStyle && (t.pixelPosition = "1%"! == (e.getComputedStyle (d, null) || {}). En haut, t.boxSizingReliable = "4px" === ( e.getComputedStyle (d, null) || {largeur: "4px"}). largeur, r = d.appendChild (a.createElement ("div")), r.style.cssText = d.style.cssText = s , r.style.marginRight = r.style.width = "0", d.style.width = "1px", t.reliableMarginRight =! parseFloat ((e.getComputedStyle (r, null) || {}). marginRight)), typeof d .style.zoom! == i && (d.innerHTML = "", d.style.cssText = s + "largeur: 1px; remplissage: 1px; affichage: inline; zoom: 1", t.inlineBlockNeedsLayout = 3 === d .offsetWidth, d.style.display = "bloquer", d.innerHTML = "<div> </ div>", d.firstChild.style.width = "5px", t.shrinkWrapBlocks = 3! == d.offsetWidth , t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild (n), n = d = o = r = null)}), n = s = l = u = r = o = null, t1 ", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display =" bloquer ", d.innerHTML =" <div> </ div> ", d.firstChild.style.width =" 5px " , t.shrinkWrapBlocks = 3! == d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild (n), n = d = o = r = null)}), n = s = l = u = r = o = nul, t1 ", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display =" bloquer ", d.innerHTML =" <div> </ div> ", d.firstChild.style.width =" 5px " , t.shrinkWrapBlocks = 3! == d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild (n), n = d = o = r = null)}), n = s = l = u = r = o = nul, t
} ({}); var B = / (?: \ {[\ s \ S] * \} | \ [[\ s \ S] * \]) $ /, P = / ([AZ]) / g ; fonction R (e, n, r, i) {if (x.acceptData (e)) {var o, a, s = x.expando, l = e.nodeType, u = l? x.cache: e, c = l? e [s]: e [s] && s; if (c && u [c] && (i || [c] .data) || r! == t || "chaîne"! = typeof n) return c || (c = l? e [s] = p.pop () || x.guid ++: s), u [c] || (u [c] = l? {}: {toJSON: x. noop}), ("objet" == typeof n || "fonction" == typeof n) && (i? u [c] = x.extend (u [c], n): u [c] .data = x.extend (u [c] .data, n)), a = u [c], je || (a.data || (a.data = {}), a = a.data), r! = = t && (a [x.camelCase (n)] = r), "chaîne" == typeof n? (o = a [n], null == o && (o = a [x.camelCase (n)])) : o = a, o}} fonction W (e, t, n) {if (x.acceptData (e)) {var r, i, o = e.nodeType, a = o? x.cache: e, s = o? e [x.expando]: x.expando; if (a [s]) {if (t && (r = n? a [s]: a [s] .data)) {x.isArray (t) ? t = t.concat (x.map (t, x.camelCase)): t dans t? t = [t] :( t = x.camelCase (t), t = t dans r? [t]: t .split ("")), i = t.length; while (i -) supprimer r [t [i]]; if (n?! I (r):! x.isEmptyObject (r)) return} (n || (supprimer un [s] .data, I (un [s]))) && (o? x.cleanData ([e],! 0): x.support.deleteExpando || a! = a.window? supprimer a [s]: a [s] = null)}}} x.extend ({cache: {}, noData: {applet:! 0, embed:! 0, objet: "clsid: D27CDB6E-AE6D-11cf- 96B8-444553540000 "}, hasData: fonction (e) {return e = e.nodeType? X.cache [e [x.expando]]: e [x.expando], !! e &&! I (e)}, données : function (e, t, n) {return R (e, t, n)}, removeData: fonction (e, t) {return W (e, t)}, _ data: fonction (e, t, n) { return R (e, t, n,! 0)}, _ removeData: fonction (e, t) {return W (e, t,! 0)}, acceptData: fonction (e) {if (e.nodeType && 1! == e.nodeType && 9! == e.nodeType) return! 1; var t = e.nodeName && x.noData [nom.noeud.toLongueCase ()]; return! t || t! ==! 0 && e.getAttribute ("classid") === t}}), x.fn.extend ({data: fonction (e, n) {var r, i,o = null, a = 0, s = cela [0]; if (e === t) {if (this.length && (o = x.data (s), 1 === s.nodeType &&! x._data (s, "parsedAttrs"))) {pour (r = s.attributs; r.length> a; a ++) i = r [a] .nom, 0 === i.indexOf ("data -") && ( i = x.camelCase (i.slice (5)), $ (s, i, o [i])); x._data (s, "parsedAttrs",! 0)} return o} return "objet" == typeof e? this.each (fonction () {x.data (ceci, e)}): arguments.length> 1? this.each (fonction () {x.data (this, e, n)}): s ? $ (s, e, x.data (s, e)): null}, removeData: fonction (e) {retourne this.each (fonction () {x.removeData (this, e)})}}); function $ (e, n, r) {if (r === t && 1 === e.nodeType) {var i = "données -" + n.replace (P, "- $ 1"). toLowerCase (); (r = e.getAttribute (i), "chaîne" == typeof r) {essayez {r = "vrai" === r?! 0: "faux" === r?! 1: "null" == = r? null: + r + "" === r? + r: B.test (r)? x.parseJSON (r):r} catch (o) {} x.data (e, n, r)} else r = t} return r} fonction I (e) {var t; pour (t dans e) if (("data"! = = t ||! x.isEmptyObject (e [t])) && "toJSON"! == t) return! 1; return! 0} x.extend ({queue: fonction (e, n, r) {var i ; return e? (n = (n || "fx") + "file d'attente", i = x._data (e, n), r && (! i || x.isArray (r)? i = x._data ( e, n, x.makeArray (r)): i.push (r)), i || []): t}, dequeue: fonction (e, t) {t = t || "fx"; var n = x.queue (e, t), r = n.length, i = n.shift (), o = x._queueHooks (e, t), a = fonction () {x.dequeue (e, t)} "inprogress" === i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("en cours"), supprimer o.stop, i.call (e, a, o)),! r && o && o.empty.fire ()}, _ queueHooks: fonction (e, t) {var n = t + "queueHooks"; renvoyer x._data (e, n) || x._data (e, n, {empty: x.Callbacks ("une fois la mémoire"). add (function () {x._removeData (e,t + "queue"), x._removeData (e, n)})})}}), x.fn.extend ({queue: fonction (e, n) {var r = 2; renvoie "chaîne"! = typeof e && (n = e, e = "fx", r -), r> arguments.length? x.queue (this [0], e): n === t? this: this.each (fonction () {var t = x.queue (ceci, e, n); x._queueHooks (this, e), "fx" === e && "en cours"! == t [0] && x.dequeue (this, e)} )}, dequeue: function (e) {retourne this.each (fonction () {x.dequeue (this, e)})}, delay: fonction (e, t) {return e = x.fx? x.fx .speeds [e] || e: e, t = t || "fx", this.queue (t, fonction (t, n) {var r = setTimeout (t, e); n.stop = fonction () {clearTimeout (r)}})}, clearQueue: function (e) {return this.queue (e || "fx", [])}, promesse: function (e, n) {var r, i = 1, o = x.Deferred (), a = ceci, s = this.length, l = fonction () {- i || o.résolveWith (a, [a])}; "chaîne"! = typeof e && (n = e, e = t), e = e || "fx"; tandis que (s -) r = x._data (a [s], e + "queueHooks"), r && r.empty && (i ++, r.empty.add (l)); return l (), o.promise (n)}}); var z, X, U = / [\ t \ r \ n \ f] / g, V = / \ r / g, Y = / ^ (?: entrée | select | textarea | bouton | objet) $ / i, J = / ^ (? : une | zone) $ / i, G = / ^ (?: coché | sélectionné) $ / i, Q = x.support.getSetAttribute, K = x.support.input; x.fn.extend ({attr: fonction (e, t) {return x.access (this, x.attr, e, t, arguments.length> 1)}, removeAttr: function (e) {retourne this.each (function () {x.removeAttr (this , e)})}, prop: fonction (e, t) {return x.access (ceci, x.prop, e, t, arguments.length> 1)}, removeProp: fonction (e) {return e = x .propFix [e] || e, this.each (function () {essayez {this [e] = t, supprimez ce [e]} catch (n) {}})}, addClass: function (e) {var t, n, r, i, o, a = 0, s = cette.longueur, l = "chaîne" == typeof e && e; if (x.isFonction (e)) renvoie this.each (fonction (t) {x (this) .addClass (e.call (this, t, this.className))}); if (l) pour (t = (e || "").match (T) || []; s> a; a ++) si (n = ceci [a], r = 1 === n.nodeType && (n.className? ("" + n.className + "") .replace (U, ""): "")) {o = 0; tandis que (i = t [o ++]) 0> r.indexOf ("" + i + "") && (r + = i + ""); n.className = x.trim (r)} renvoie this}, removeClass: fonction (e) {var t, n, r, i, o, a = 0, s = this.length, l = 0 === arguments.length | | "string" == typeof e && e; if (x.isFonction (e)) renvoie this.each (fonction (t) {x (this) .removeClass (e.call (ceci, t, this.className))}) ; if (l) pour (t = (e || ""). match (T) || []; s> a; a ++) if (n = ceci [a], r = 1 === n.nodeType && (n.className? ("" + n.className + "") .replace (U, ""): "")) {o = 0; tandis que (i = t [o ++]) while (r.indexOf ("" + i + "")> = 0) r = r.replace ("" + i + "", ""); n.className = e? x.trim (r): ""} return this}, toggleClass: fonction (e, t) {var n = typeof e; return" booléen "== typeof t &&" chaîne "=== n? t? this.addClass (e): this.removeClass ( e): x.isFonction (e)? this.each (fonction (n) {x (this) .toggleClass (e.call (ceci, n, this.className, t), t)}): this.each ( function () {if ("chaîne" === n) {var t, r = 0, o = x (ceci), a = e.match (T) || []; while (t = a [r ++] ) o.hasClass (t)? o.removeClass (t): o.addClass (t)} else (n === i || "booléen" === n) && (this.className && x._data (this, " __className __ ", this.className), this.className = this.nom_classe || e ===! 1?" ": x._data (this," __ className __ ") ||" ")})}, hasClass: function ( e) {var t = "" + e + "", n = 0, r = this.length; pour (; r> n; n ++) if (1 === this [n] .nodeType && ("" + ceci [ n] .className + "") .replace (U, "") .indexOf (t)>= 0) return! 0; return! 1}, val: function (e) {var n, r, i, o = ce [0]; {if (arguments.length) renvoie i = x.isFonction (e), this.each (fonction (n) {var o; 1 === this.nodeType && (o = i? e.call (ceci, n, x (this) .val ()): e, null == o? o = "": "nombre" == typeof o? o + = "": x.isArray (o) && (o = x.map (o, fonction (e) {return null == e? "": e + "" })), r = x.valHooks [ce.type] || x.valHooks [this.NodeName.toLowerCase ()], r && "set" dans r && r.set (this, o, "value")! == t || (this.value = o))}); si (o) renvoie r = x.valHooks [o.type] || x.valHooks [o.nodeName.toLowerCase ()], r && "get" dans r && ( n = r.get (o, "valeur"))! == t? n: (n = o.valeur, "chaîne" == typeof n? n.replace (V, ""): null == n? "": n)}}}), x.extend ({valHooks: {option: {get: fonction (e) {var t = x.find.attr (e, "valeur"); return null! = t? t: e.text}}, sélectionnez: {get: function (e) {var t, n, r = e.options, i = e.selectedIndex, o = "select-one" === e.type || 0> i, a = o? null: [], s = o? i + 1: r.length, l = 0> i? s: o? i: 0; pour (; s> l; l ++) if (n = r [ l],! (! n.selected && l! == i || (x.support.optDisabled? n.disabled: null! == n.getAttribute ("désactivé")) || n.parentNode.disabled && x.nodeName (n .parentNode, "optgroup"))) {if (t = x (n) .val (), o) renvoie t; a.push (t)} renvoie un}, set: function (e, t) {var n , r, i = e.options, o = x.makeArray (t), a = i.length; tandis que (a -) r = i [a], (r.selected = x.inArray (x (r)) .val (), o)> = 0) && (n =! 0); renvoie n || (e.selectedIndex = -1), o}}}, attr: fonction (e, n, r) {var o , a, s = e.nodeType; if (e && 3! == s && 8! == s && 2! == s) return typeof e.getAttribute === i.x.prop (e, n, r) :( 1 == = s && x.isXMLDoc (e) || (n = n.àLongueurCase (), o = x.attrHooks [n] || (x.expr.match.bool.test (n)? X: z)), r = == t? o && "obtenir "dans o && null! == (a = o.get (e, n))? a: (a = x.find.attr (e, n), null == a? t: a): null! == r? o && "set" dans o && (a = o.set (e, r, n))! == t? a: (e.setAttribute (n, r + ""), r) :( x.removeAttr (e , n), t))}, removeAttr: fonction (e, t) {var n, r, i = 0, o = t && t.match (T); si (o && 1 === e.nodeType) while (n = o [i ++]) r = x.propFix [n] || n, x.expr.match.bool.test (n)? K && Q ||! G.test (n)? e [r] =! 1: e [x.camelCase ("default -" + n)] = e [r] =! 1: x.attr (e, n, ""), e.removeAttribute (Q? n: r)}, attrHooks: {type : {set: function (e, t) {if (! x.support.radioValue && "radio" === t && x.nodeName (e, "entrée")) {var n = e.value; retourne e.setAttribute (" type ", t), n && (e.value = n), t}}}}, propFix: {" pour ":" htmlFor "," class ":" className "}, prop: fonction (e, n, r ) {var i, o, a, s = e.nodeType; if (e && 3!== s && 8! == s && 2! == s) renvoient a = 1! == s ||! x.isXMLDoc (e), a && (n = x.propFix [n] || n, o = x.propHooks [ n]), r! == t? o && "set" dans o && (i = o.set (e, r, n))! == t? i: e [n] = r: o && "get" dans o && null ! == (i = o.get (e, n))? i: e [n]}, propHooks: {tabIndex: {get: fonction (e) {var t = x.find.attr (e, "tabindex "); return t? parseInt (t, 10): Y.test (nom.noeud) || J.test (e.nodeName) && e.href? 0: -1}}}}), X = {set: function (e, t, n) {return t ===! 1? x.removeAttr (e, n): K && Q ||! G.test (n)? e.setAttribute (! Q && x.propFix [n] || n, n): e [x.camelCase ("default -" + n)] = e [n] =! 0, n}}, x.each (x.expr.match.bool.source.match (/ \ w + / g), fonction (e, n) {var r = x.expr.attrHandle [n] || x.find.attr; x.expr.attrHandle [n] = K && Q ||! G.test (n) ? function (e, n, i) {var o = x.expr.attrHandle [n], a = i? t: (x.expr.attrHandle [n] = t)! = r (e, n, i) ? n.toLowerCase (): null;return x.expr.attrHandle [n] = o, a}: fonction (e, n, r) {return r? t: e [x.camelCase ("default -" + n)]? n.toLongueCase (): null}}), K && Q || (x.attrHooks.value = {set: fonction (e, n, r) {return x.nodeName (e, "entrée")? (e.defaultValue = n, t): z && z .set (e, n, r)}}, Q || (z = {set: fonction (e, n, r) {var i = e.getAttributeNode (r); retourne i || e.setAttributeNode (i = e.ownerDocument.createAttribute (r)), i.value = n + = "", "valeur" === r || n === e.getAttribute (r)? n: t}}, x.expr. attrHandle.id = x.expr.attrHandle.name = x.expr.attrHandle.coords = fonction (e, n, r) {var i; renvoie r? t: (i = e.getAttributeNode (n)) && "" ! == i.value? i.value: null}, x.valHooks.button = {get: fonction (e, n) {var r = e.getAttributeNode (n); return r && r.specifié? r.valeur: t }, set: z.set}, x.attrHooks.contenteditable = {set: fonction (e, t, n) {z.set (e, "" === t ?! 1: t, n)}}, x.each (["width "," height "], fonction (e, n) {x.attrHooks [n] = {ensemble: function (e, r) {return" "=== r? (e.setAttribute (n," auto " ), r): t}}}), x.support.hrefNormalized || x.each (["href", "src"], la fonction (e, t) {x.propHooks [t] = {get: function (e) {return e.getAttribute (t, 4)}}}), x.support.style || (x.attrHooks.style = {get: function (e) {return e.style.cssText || t }, définissez: function (e, t) {return e.style.cssText = t + ""}}), x.support.optSelected || (x.propHooks.selected = {get: function (e) {var t = e.parentNode; renvoie t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null}}), x.each (["tabIndex", "readOnly", "longueurLong", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], fonction () {x.propFix [this.toLowCase ()] = this}), x.support.enctype || (x.propFix.enctype = "encoding"), x.each (["radio", "case à cocher"], function () { x.valHooks [this] = {set: fonction (e, n) {return x.isArray (n)? e.checked = x.inArray (x (e) .val (), n)> = 0: t} }, x.support.checkOn || (x.valeursHooks [this] .get = fonction (e) {return null === e.getAttribute ("valeur")? "on": e.value})}); var Z = / ^ (?: input | select | textarea) $ / i, et = / ^ touche /, tt = / ^ (?: souris | contextmenu) | click /, nt = / ^ (?: focusinfocus | focusoutblur ) $ /, rt = / ^ ([^.] *) (?: \. (. +) |) $ /; la fonction () {return! 0} fonction ot () {return! 1} fonctionne à ( ) {try {return a.activeElement} attrape (e) {}} x.event = {global: {}, ajoute: fonction (e, n, r, o, a) {var s, l, u, c, p, f, d, h, g, m, y, v = x._data (e); si (v) {r.handler && (c = r, r = c.handler, un = c.selecteur), r .guid || (r.guid = x.guid ++), (l = v.events) || (l = v.events = {}), (f = v.handle) || (f = v.handle = function (e) {return type de x === i || e && x.event.triggered === e.type? t: x.event.dispatch.apply (f.elem, arguments)}, f.elem = e), n = (n || ""). match (T) || [""], u = n.longueur; tandis que (u-) s = rt.exec (n [u]) || [ ], g = y = s [1], m = (s [2] || ""). split ("."). sort (), g && (p = x.event.special [g] || { }, g = (a? p.delegateType: p.bindType) || g, p = x.événement.spécial [g] || {}, d = x.extend ({type: g, origType: y, data : o, gestionnaire: r, guid: r.guid, sélecteur: a, needsContext: un && x.expr.match.needsContext.test (a), espace de noms: m.join (".")}, c), (h = l [g]) || (h = l [g] = [], h.delegateCount = 0, p.setup && p.setup.call (e, o, m, f)! ==! 1 || (e. addEventListener? e.addEventListener (g, f,! 1): e.attachEvent && e.attachEvent ("on" + g, f)), p.add && (p.add.call (e, d), d.handler. guid || (d.handler.guid = r.guid)), un? h.splice (h.delegateCount ++, 0, d): h.push (d), x.event.global [g] =! 0); e = null}}, supprimer: fonction (e, t, n, r, i) {var o, a, s, l, u, c, p, f, d, h , g, m = x.hasData (e) && x._data (e); if (m && (c = m.events)) {t = (t || ""). correspondance (T) || [""] , u = t.length, tandis que (u -) si (s = rt.exec (t [u]) || [], d = g = s [1], h = (s [2] || " ") .split (". "). sort (), d) {p = x.événement.spécial [d] || {}, d = (r? p.delegateType: p.bindType) || d, f = c [d] || [], s = s [2] && RegExp ("(^ | \\.)" + h.join ("\\. (?:. * \\. |)") +) (\\. | $) "), l = o = f.length; tandis que (o -) a = f [o],! i && g! == a.origType || n && n.guid! == a.guid || s &&! s.test (a.namespace) || r && r! == a.selector && ("**"! == r ||! a.selecteur) || (f.splice (o, 1), a .selector && f.delegateCount -, p.remove && p.remove.call (e, a)); l &&! f.length && (p.teardown && p.teardown.call (e, h, m.handle)! ==! 1 || x.removeEvent (e, d, m.handle),supprimer c [d])} else pour (d dans c) x.event.remove (e, d + t [u], n, r,! 0); x.isEmptyObject (c) && (supprimer m.handle, x._removeData (e, "events"))}}, trigger: fonction (n, r, i, o) {var s, l, u, c, p, f, d, h = [i || a] , g = v.call (n, "type")? n.type: n, m = v.call (n, "espace de nommage")? n.namespace.split ("."): []; if (u = f = i = i || a, 3! == i.nodeType && 8! == i.nodeType &&! nt.test (g + x.event.trigger) && (g.indexOf (".")> = 0 && ( m = g.split ("."), g = m.shift (), m.sort ()), l = 0> g.indexOf (":") && "on" + g, n = n [x .expando]? n: nouveau x.Evénement (g, "objet" == typeof n && n), n.isTrigger = o? 2: 3, n.namespace = m.join ("."), n.namespace_re = n .namespace? RegExp ("(^ | \\.)" + m.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, n .result = t, n.target || (n.target = i), r = null == r? [n]: x.makeArray (r, [n]),p = x.event.special [g] || {}, o ||! p.trigger || p.trigger.apply (i, r)! ==! 1)) {if (! o &&! p.noBubble && ! x.isWindow (i)) {pour (c = p.delegateType || g, nt.test (c + g) || (u = u.parentNode); u; u = u.parentNode) h.push ( u), f = u; f === (i.ownerDocument || a) && h.push (f.defaultView || f.parentWindow || e)} d = 0; while ((u = h [d ++]) &&! n.isPropagationStopped ()) n.type = d> 1? c: p.bindType || g, s = (x._données (u, "événements") || {}) [n.type] && x. _data (u, "handle"), s && s.apply (u, r), s = l && u [l], s && x.acceptData (u) && s.apply && s.apply (u, r) ===! 1 && n.preventDefault () ; if (n.type = g,! o &&! n.isDefaultPrevented () && (! p._default || p._default.apply (h.pop (), r) === 1) && x.acceptData (i ) && l && i [g] &&! x.isWindow (i)) {f = i [l], f && (i [l] = null), x.event.triggered = g; essayez {i [g] ()} catch (y) {} x.événement.triggered = t, f && (i [l] = f)} return n.result}}, envoi: function (e) {e = x.event.fix (e); var n, r, i, o, a, s = [], l = g.call (arguments), u = (x._data (ceci, "événements") || {}) [e.type] || [], c = x.event.special [ e.type] || {}; si (l [0] = e, e.delegateTarget = ceci,! c.preDispatch || c.preDispatch.call (ceci, e)! ==! 1) {s = x .event.handlers.call (this, e, u), n = 0, alors que ((o = s [n ++]) &&! e.isPropagationStopped ()) {e.currentTarget = o.elem, a = 0; ((i = o.handlers [a ++]) &&! e.isImmediatePropagationStopped ()) (! e.namespace_re || e.namespace_re.test (i.namespace)) && (e.handleObj = i, e.data = i .data, r = ((x.event.special [i.origType] || {}). handle || i.handler) .apply (o.élément, l), r! == t && (e.result = r) ===! 1 && (e.preventDefault (), e.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (this, e), e.result}}, gestionnaires: function (e, n) {var r, i, o, a, s = [], l = n.delegateCount, u = e.target; if (l && u.nodeType && (! e.button || "cliquez sur"! == e.type)) pour (; u! = this; u = u.parentNode || this) if (1 === u. nodeType && (u.disabled! ==! 0 || "cliquez sur"! == e.type)) {pour (o = [], a = 0; l> a; a ++) i = n [a], r = i.selector + "", o [r] === t && (o [r] = i.needsContext? x (r, this) .index (u)> = 0: x.find (r, this, null, [ u]). longueur), o [r] && o.push (i); o.length && s.push ({elem: u, gestionnaires: o})} return n.length> l && s.push ({elem: this, gestionnaires : n.slice (l)}, s}, fix: fonction (e) {if (e [x.expando]) renvoie e; var t, n, r, i = e.type, o = e, s = this.fixHooks [i]; s || (this.fixHooks [i] = s = tt.test (i)? cette.mouseHooks: et.test (i)? this.keyHooks: {}), r = s .props? this.props.concat (s.props): this.props, e = nouveau x.Event (o), t = r.length; while (t -) n = r [t], e [n ] = o [n]; renvoie e.target || (e.target = o.srcElement || a), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !! e.metaKey, s.filter? s.filter (e, o): e}, les accessoires: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey cible timeStamp vue qui" .split (""), fixHooks: {}, keyHooks: {props: "char charCode key keyCode" .split (""), filtre: fonction (e, t) {return null == e.qui && (e.which = null! = t.charCode? t .charCode: t.keyCode), e}}, mouseHooks: {props: "boutons de commande clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY àElement" .split (""), filtre: function (e, n) {var r, i, o, s = n.bouton, l = n.fromElement; renvoyer null == e.pageX && null! = n.clientX && (i = e.target.ownerDocument || a, o = i.documentElement, r = i. corps, e.pageX = n.clientX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0), e.pageY = n.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0)),! e.relatedTarget && l && (e.relatedTarget = l === e.target? n.toElement : l), e.qui || s === t || (e.which = 1 & s? 1: 2 & s? 3: 4 & s? 2: 0), e}}, special: {load: {noBubble:! 0 }, focus: {trigger: function () {if (this! == à () && this.focus) try {retourne this.focus (),! 1} catch (e) {}}, delegateType: "focusin"} , flou: {trigger: function () {return this === à () && this.blur? (this.blur (),! 1): t}, delegateType: "focusout"}, cliquez sur: {trigger: function ( ) {return x.nodeName (this, "entrée") && "case à cocher" === this.type && this.click? (this.click (),! 1): t}, _ par défaut: function (e) {return x. nodeName (e.target, "a")}}, beforeunload: {postDispatch: fonction (e) {e.result! == t && (e.originalEvent.returnValue = e.result)}}},simuler: fonction (e, t, n, r) {var i = x.extend (nouveau x.Event, n, {type: e, isSimulated:! 0, originalEvent: {}}); r? x.event. trigger (i, null, t): x.event.dispatch.call (t, i), i.isDefaultPrevented () && n.preventDefault ()}, x.removeEvent = a.removeEventListener? function (e, t, n ) {e.removeEventListener && e.removeEventListener (t, n,! 1)}: fonction (e, t, n) {var r = "on" + t; e.detachEvent && (typeof e [r] === i && [r] = null), e.detachEvent (r, n))}, x.Event = fonction (e, n) {renvoie cette instance de x.Event? (e && e.type? (this.originalEvent = e, this. type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue ===! 1 || e.getPreventDefault && e.getPreventDefault ()? it: ot): this.type = e, n && x.extend (ceci, n), this.timeStamp = e && e.timeStamp || x.now (), ce [x.expando] =! 0, t): nouveau x.Event (e, n)}, x.Event.prototype = {isDefaultPrevented : ot,isPropagationStopped: ot, isImmediatePropagationStopped: ot, preventDefault: function () {var e = cet.originalEvent; this.isDefaultPrevented = it, e && (e.preventDefault? e.preventDefault (): e.returnValue =! 1)}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = it, e && (e.stopPropagation && e.stopPropagation (), e.cancelBubble =! 0)}, stopImmediatePropagation: function () {this.isImmediatePropagationStopped = it, this. stopPropagation ()}}, x.each ({mouseenter: "mouseover", mouseleave: "mouseout"}, fonction (e, t) {x.event.special [e] = {type_joint: t, bindType: t, handle : function (e) {var n, r = ceci, i = e.relatedTarget, o = e.handleObj; return (! i || i! == r &&! x.contains (r, i)) && (e. type = o.origType, n = o.handler.apply (this, arguments), e.type = t), n}}}), x.support.submitBubbles || (x.event.special.submit = {setup : function () {return x.nodeName (this, "form") ?! 1: (x.event.add (ceci, "click._submit keypress._submit", fonction (e) {var n = e.target, r = x.nodeName (n, "input") || x.nodeName (n, "bouton")? n.form: t; r &&! x._data (r, "submitBubbles") && (x.event.add (r, "submit._submit" , fonction (e) {e._submit_bubble =! 0}), x._data (r, "submitBubbles",! 0))}), t)}, postDispatch: fonction (e) {e._submit_bubble && (supprimer e. _submit_bubble, this.parentNode &&! e.isTrigger && x.event.simulate ("soumettre", this.parentNode, e,! 0))}, démontage: function () {return x.nodeName (this, "formulaire") ?! 1 : (x.event.remove (this, "._ submit"), t)}}), x.support.changeBubbles || (x.event.special.change = {setup: function () {return Z.test ( this.nodeName)? (("case à cocher" === this.type || "radio" === this.type) && (x.event.add (this, "propertychange._change", function (e) {"vérifié" === e.originalEvent.propertyName && (this._just_changed =! 0)}), x.event.add (this, "click._change" , function (e) {this._just_changed &&! e.isTrigger && (this._just_changed =! 1), x.event.simulate ("change", this, e,! 0)})), 1) :( x. event.add (this, "beforeactivate._change", la fonction (e) {var t = e.target; Z.test (t.nodeName) &&! x._data (t, "changeBubbles") && (x.event. add (t, "change._change", function (e) {! this.parentNode || e.isSimulé || e.isTrigger || x.event.simulate ("change", this.parentNode, e,! 0) }), x._data (t, "changeBubbles",! 0))}), t)}, manipule: function (e) {var n = e.target; retourne ceci! == n || e.isSimulated | | e.isTrigger || "radio"! == n.type && "case à cocher"! == n.type? e.handleObj.handler.apply (this, arguments): t}, démontage: function () {return x.event.remove (ceci, "._ change"),! Z.test (this.nodeName)}}, x.support.focusinBubbles | | x.each ({focus: "focusin", flou: "focusout"}, fonction (e, t) {var n = 0, r = fonction (e) {x.event.simulate (t, e.target, x.event.fix (e),! 0)}; x.event.special [t] = {configuration: function () {0 === n ++ && a.addEventListener (e, r,! 0)}, teardown: function () {0 === - n && a.removeEventListener (e, r,! 0)}}}), x.fn.extend ({on: fonction (e, n, r, i, o) { var a, s; if ("objet" == typeof e) {"chaîne"! = typeof n && (r = r || n, n = t); pour (a dans e) this.on (a, n, r, e [a], o); renvoyer this} if (null == r && null == i? (i = n, r = n = t): null == i && ("string" == typeof n? (i = r, r = t) :( i = r, r = n, n = t)), i === 1) i = ot; sinon si (! i) renvoie ceci; return 1 === o && ( s = i, i = fonction (e) {return x (). off (e), s.apply (ceci, arguments)}, i.guid = s.guid || (s.guid = x.guid ++)), this.each (function () {x.event.add (ceci, e, i, r, n)}), un: function (e, t, n, r) {return this.on (e, t, n, r, 1)}, off: fonction (e, n, r) {var i, o; si (e && e.preventDefault && e.handleObj) renvoie i = e .handleObj, x (e.delegateTarget) .off (i.namespace? i.origType + "." + i.namespace: i.origType, i.selector, i.handler), if ("objet" == typeof e) {pour (o en e) this.off (o, n, e [o]); renvoyer cette fonction} return (n ===! 1 || "fonction" == typeof n) && (r = n, n = t), r ===! 1 && (r = ot), this.each (fonction () {x.event.remove (ceci, e, r, n)}), déclencheur: function (e, t ) {return this.each (fonction () {x.event.trigger (e, t, this)}), triggerHandler: fonction (e, n) {var r = this [0]; renvoie r? x.event .trigger (e, n, r,! 0): t}}); var st = / ^. [^: # \ [\.,] * $ /, lt = / ^ (?: parents | prev (? : Jusqu'à | Tout)) /, ut = x.expr.match.needsContext, ct = {enfants:! 0, contenu:! 0, suivant:! 0, prev:! 0}; x.fn.extend ({find: function (e) {var t, n = [], r = ceci, i = r.length; if ("chaîne"! = typeof e) retourne this.pushStack (x (e) .filter ( function () {pour (t = 0; i> t; t ++) if (x.contains (r [t], this)) return! 0})); pour (t = 0; i> t; t ++) x .find (e, r [t], n); renvoie n = this.pushStack (i> 1? x.unique (n): n), n.selector = this.selector? this.selector + "" + e: e, n}, a: fonction (e) {var t, n = x (e, ce), r = n.length; return this.filter (fonction () {pour (t = 0; r> t; t ++ ) if (x.contains (this, n [t])) renvoie! 0})}, not: function (e) {retourne this.pushStack (ft (this, e || [],! 0))}, filter: function (e) {return this.pushStack (ft (ceci, e || [],! 1))}, est: function (e) {return !! ft (ceci, "string" == typeof e && ut. test (e)? x (e): e || [],! 1) .length}, plus proche: fonction (e, t) {var n, r = 0, i = cette.longueur, o = [], a = ut.test (e) || "chaîne"! = typeof e? x (e, t || this.context): 0; pour (; i> r; r ++) pour (n = this [r]; n && n! == t; n = n.parentNode) if (11> n.nodeType && (un? a.index (n)> - 1: 1 === n.nodeType && x.find.matchesSelector (n, e))) {n = o.push (n); break} renvoie this.pushStack (o.length> 1? x.unique (o): o)}, index: fonction (e) {return e? "chaîne" == typeof e? x.inArray (this [0] , x (e)): x.inArray (e.jquery? e [0]: e, this): ceci [0] && this [0] .parentNode? this.first (). prevAll (). longueur: -1 }, ajoutez: function (e, t) {var n = "chaîne" == typeof e? x (e, t): x.makeArray (e && e.nodeType? [e]: e), r = x.merge ( this.get (), n); return this.pushStack (x.unique (r))}, addBack: function (e) {renvoyer this.add (null == e? this.prevObject: this.prevObject.filter ( e))}}); function pt (e, t) {faire e = e [t]; while (e && 1! == e.nodeType); retourner e} x.each ({parent: function (e) {var t = e.parentNode; return t && 11! == t.nodeType? t: null}, parents: function (e) {return x.dir (e, "parentNode")}, parentsUntil: fonction (e, t,n) {return x.dir (e, "parentNode", n)}, ensuite: function (e) {return pt (e, "nextSibling")}, prev: fonction (e) {return pt (e, "previousSibling ")}, nextAll: function (e) {renvoyer x.dir (e," nextSibling ")}, prevAll: function (e) {renvoyer x.dir (e," previousSibling ")}, nextUntil: function (e, t, n) {return x.dir (e, "nextSibling", n)}, prevUntil: function (e, t, n) {renvoyer x.dir (e, "previousSibling", n)}, soeurs: function ( e) {return x.sibling ((e.parentNode || {}). firstChild, e)}, enfants: function (e) {return x.sibling (e.firstChild)}, contenu: function (e) {return x.nodeName (e, "iframe")? e.contentDocument || e.contentWindow.document: x.merge ([], e.childNodes)}}, fonction (e, t) {x.fn [e] = function (n, r) {var i = x.map (ceci, t, n); return "Until"! == e.slice (-5) && (r = n), r && "string" == typeof r && (i = x.filter (r,i)), this.length> 1 && (ct [e] || (i = x.unique (i)), lt.test (e) && (i = i.reverse ())), this.pushStack (i )}}), x.extend ({filtre: fonction (e, t, n) {var r = t [0]; renvoie n && (e = ": non (" + e + ")"), 1 === t.length && 1 === r.nodeType? x.find.matchesSelector (r, e)? [r]: []: x.find.matches (e, x.grep (t, fonction (e) {return 1 = == e.nodeType}))}, dir: fonction (e, n, r) {var i = [], o = e [n]; while (o && 9! == o.nodeType && (r === t | | 1! == o.nodeType ||! X (o) .is (r))) 1 === o.nodeType && i.push (o), o = o [n]; renvoyer i}, frère: function ( e, t) {var n = []; pour (; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}}); fonction ft (e, t, n) {if (x.isFonction (t)) renvoie x.grep (e, fonction (e, r) {renvoyer !! t.call (e, r, e)! == n}); if ( t.nodeType) return x.grep (e, fonction (e) {return e === t! == n}); if ("chaîne" == typeof t) {if (st.test (t)) return x.filter (t, e, n); t = x.filter (t, e)} return x.grep (e, fonction (e) {renvoyer x.inArray (e, t)> = 0! == n})} fonction dt (e) {var t = ht.split ("|"), n = e.createDocumentFragment (); if (n.createElement) while (t.length) n.createElement (t.pop ()); renvoyer n} var ht = "abbr | article | aside | audio | bdi | toile | données | datalist | détails | figcaption | figure | pied de page | en-tête | hgroup | marque | compteur | nav | sortie | progression | section | résumé | temps | vidéo ", gt = / jQuery \ d + =" ( ?: null | \ d +) "/ g, mt = RegExp (" <(?: "+ ht +") [\\ s />] "," i "), yt = / ^ \ s + /, vt = / <(?! area | br | col | embed | hr | img | entrée | lien | méta | param) (([\ w:] +) [^>] *) \ /> / gi, bt = / <( [\ w:] +) /, xt = / <tbody / je, wt = / <| & #? \ w +; /, Tt = / <(?: script | style | lien) / i, Ct = / ^ (?: checkbox | radio) $ / i, Nt = / vérifié \ s * (?: [^ =] | = \ s * .checké.) / i, kt = / ^ $ | \ / (?: java | ecma) script / i, Et = / ^ vrai \ / (. *) /, St = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | - -)> \ s * $ / g,At = {option: [1, "<select multiple = 'multiple'>", "</ select>"], légende: [1, "<fieldset>", "</ fieldset>"], zone: [1 , "<map>", "</ map>"], param: [1, "<objet>", "</ object>"], thead: [1, "<table>", "</ table> "], tr: [2," <table> <tbody> "," </ tbody> </ table> "], col: [2," <table> <tbody> </ tbody> <colgroup> ", "</ colgroup> </ table>"], td: [3, "<table> <corps> <tr>", "</ tr> </ tbody> </ table>"], _ default: x.support .htmlSerialize? [0, "", ""]: [1, "X <div>", "</ div>"]}, jt = dt (a), Dt = jt.appendChild (a.createElement (" div ")); At.optgroup = At.option, At.tbody = At.tfoot = At.colgroup = At.caption = At.thead, At.th = At.td, x.fn.extend ({texte: function (e) {return x .access (this, function (e) {Renvoie e === t? x.text (this): this.empty (). append ((this [0] && this [0] .ownerDocument || a) .createTextNode ( e))}, null, e, arguments.length)}, append: function () {Renvoie this.domManip (arguments, fonction (e) {if (1 === this.nodeType || 11 === this. nodeType || 9 === this.nodeType) {var t = Lt (ceci, e); t.appendChild (e)}})}, préfixe: function () {return this.domManip (arguments, fonction (e)) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Lt (ceci, e); t.insertBefore (e, t.firstChild) }})}, avant: function () {return this.domManip (arguments, fonction (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, après: function () {return this.domManip ( arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e,this.nextSibling)})}, remove: fonction (e, t) {var n, r = e? x.filter (e, this): ceci, i = 0; pour (; null! = (n = r [ i]); i ++) t || 1! == n.nodeType || x.cleanData (Ft (n)), n.parentNode && (t && x.contains (n.ownerDocument, n) && _ t (Ft (n, "script ")), n.parentNode.removeChild (n)); renvoyer ce}, vide: function () {var e, t = 0; pour (; null! = (e = ce [t]); t ++) {1 === e.nodeType && x.cleanData (Ft (e,! 1)); while (e.firstChild) e.removeChild (e.firstChild); e.options && x.nodeName (e, "select") && (e.options .length = 0)} return this}, clone: ​​fonction (e, t) {return e = null == e?! 1: e, t = null == t? e: t, this.map (fonction () {return x.clone (this, e, t)}), html: function (e) {return x.access (this, fonction (e) {var n = this [0] || {}, r = 0 , i = this.length; if (e === t) renvoie 1 === n.nodeType? n.innerHTML.replace (gt, ""): t; if (! ("chaîne"! = typeof e | | Tt.test (e) ||! X.support.htmlSerialize && mt.test (e) ||! x.support.leadingWhitespace && yt.test (e) || A [(bt.exec (e) || ["", ""]) [1] .toLowerCase ()])) {e = e.replace (vt, "<$ 1> </ $ 2>"); essayez {pour (; i> r; r ++) n = ce [r] || {}, 1 === n.nodeType && ( x.cleanData (Ft (n,! 1)), n.innerHTML = e); n = 0} catch (o) {}} n && this.empty (). append (e)}, null, e, arguments.length )}, replaceWith: function () {var e = x.map (this, fonction (e) {return [e.nextSibling, e.parentNode]}), t = 0; retourne this.domManip (arguments, fonction (n ) {var r = e [t ++], i = e [t ++]; i && (r && r.parentNode! == i && (r = this.nextSibling), x (ceci) .remove (), i.insertBefore (n, r ))},! 0), t? Ceci: this.remove ()}, detach: function (e) {renvoyer this.remove (e,! 0)}, domManip: fonction (e, t, n) {e = d.appliquer ([], e); var r, i, o, a, s, l, u = 0, c = cette.longueur, p = ceci, f = c-1, h = e [0] , g = x.isFonction (h); if (g ||! (1> = c || "chaîne"!= typeof h || x.support.checkClone) && Nt.test (h)) retourne this.each (fonction (r) {var i = p.eq (r); g && (e [0] = h.call (ceci , r, i.html ())), i.domManip (e, t, n)}); si (c && (l = x.buildFragment (e, ce [0] .ownerDocument,! 1,! n && this), r = l.firstChild, 1 === l.childNodes.length && (l = r), r)) {pour (a = x.map (Ft (l, "script"), Ht), o = a.length ; c> u; u ++) i = l, u! == f && (i = x.clone (i,! 0,! 0), o && x.merge (a, Ft (i, "script")), t .call (this [u], i, u); si (o) pour (s = a [a.length-1] .ownerDocument, x.map (a, qt), u = 0; o> u; u ++ ) i = a [u], kt.test (i.type || "") &&! x._data (i, "globalEval") && x contient (s, i) && (i.src? x._evalUrl ( i.src): x.globalEval ((i.text || i.textContent || i.innerHTML || ""). replace (St, ""))); l = r = null} renvoie ceci}}) ; fonction Lt (e, t) {return x.nodeName (e, "table") && x.nodeName (1 === t.nodeType? t: t.firstChild, "tr")? e.getElementsByTagName ("tbody") [0] || e.appendChild (e.ownerDocument.createElement ("tbody")): e} fonction Ht (e) {return e.type = (null! == x.find.attr (e, "type")) + "/" + e.type, e} fonction qt (e) {var t = Et.exec (type.type); return t? E.type = t [1]: e.removeAttribute ("type"), e} fonction _t (e, t) {var n, r = 0; pour ( ; null! = (n = e [r]); r ++) x._data (n, "globalEval",! t || x._data (t [r], "globalEval"))} fonction Mt (e, t ) {if (1 === t.nodeType && x.hasData (e)) {var n, r, i, o = x._data (e), a = x._data (t, o), s = o.events ; if (s) {delete a.handle, a.events = {}; pour (n dans s) pour (r = 0, i = s [n] .length; i> r; r ++) x.event.add (t, n, s [n] [r])} a.data && (a.data = x.extend ({}, a.data))}} fonction Ot (e, t) {var n, r, i ; if (1 === t.nodeType) {if (n = t.nodeName.toLongueCase (),! x.support.noCloneEvent && t [x.expando]) {i = x._data (t); pour (r dans i.events) x.removeEvent (t, r, i.handle); t.removeAttribute (x.expando)} "script" === n && t .text! == e.text? (Ht (t) .text = e.text, qt (t)): "objet" === n? (t.parentNode && (t.outerHTML = e.outerHTML), x .support.html5Clone && e.innerHTML &&! x.trim (t.innerHTML) && (t.innerHTML = e.innerHTML)): "entrée" === n && Ct.test (type.e.)? (t.defaultChecked = t.checked = e.checked, t.value! == e.value && (t.value = e.value)): "option" === n? t.defaultSelected = t.selected = e.defaultSelected :( "input" = == n || "textarea" === n) && (t.defaultValue = e.defaultValue)}} x.each ({appendTo: "append", prependTo: "préfixe", insertBefore: "before", insertAfter: "après", remplacerAll: "replaceWith"}, fonction (e, t) {x.fn [e] = fonction (e) {var n, r = 0, i = [],o = x (e), a = o.length-1; pour (; a> = r; r ++) n = r === a: ceci: this.clone (! 0), x (o [r]) [t] (n), h.applique (i, n.get ()), retourne this.pushStack (i)}}); fonction Ft (e, n) {var r, o, a = 0, s = typeof e.getElementsByTagName! == i? e.getElementsByTagName (n || "*"): typeof e.querySelectorAll! == i? e.querySelectorAll (n || "*"): t; si (! s) pour (s = [], r = e.childNodes || e; null! = (o = r [a]); a ++)! n || x.nodeName (o, n)? s.push (o): x .merge (s, Ft (o, n)); return n === t || n && x.nodeName (e, n)? x.merge ([e], s): s} fonction Bt (e) {Ct .test (e.type) && (e.defaultChecked = e.checked)} x.extend ({clone: ​​fonction (e, t, n) {var r, i, o, a, s, l = x.contains (e.ownerDocument, e); if (x.support.html5Clone || x.isXMLDoc (e) ||! mt.test ("<" + e.nodeName + ">")? o = e.cloneNode (! 0 ) :( Dt.innerHTML = e.outerHTML, Dt.removeChild (o = Dt.firstChild)),! (X.support.noCloneEvent && x.support.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || x.isXMLDoc (e))) pour (r = Ft (o), s = Ft (e), a = 0; null! = (I = s [a]); + + a) r [a] && Ot (i, r [a]); si (t) si (n) pour (s = s || Ft (e), r = r || Ft (o), a = 0 ; null! = (i = s [a]); a ++) Mt (i, r [a]); sinon Mt (e, o); renvoyer r = Ft (o, "script"), r.length> 0 && _ t (r,! l && Ft (e, "script")), r = s = i = nul, o}, buildFragment: fonction (e, t, n, r) {var i, o, a, s, l, u , c, p = e.length, f = dt (t), d = [], h = 0, pour (; p> h; h ++) si (o = e [h], o || 0 === o) if ("objet" === x.type (o)) x.merge (d, o.nodeType? [o]: o); sinon if (wt.test (o)) {s = s || f.appendChild (t.createElement ("div")), l = (bt.exec (o) || ["", ""]) [1] .toLongueCase (), c = At ​​[l] || At ._default, s.innerHTML = c [1] + o.replace (vt, "<$ 1> </ $ 2>") + c [2], i = c [0]; tandis que (i -) s = s .lastChild; if (! x.support.leadingWhitespace && yt.test (o) && d.push (t.createTextNode (yt.exec (o) [0])),! x.support.tbody) {o = "table "! == l || xt.test (o)?" <table> "! == c [1] || xt.test (o)? 0: s: s.firstChild, i = o && o.childNodes. length; while (i -) x.noeudNon (u = o.childNodes [i], "tbody") &&! u.childNodes.length && o.removeChild (u)} x.merge (d, s.childNodes), s .textContent = ""; while (s.firstChild) s.removeChild (s.firstChild); s = f.lastChild} autre d.push (t.createTextNode (o)); s && f.removeChild (s), x.support .appendChecked || x.grep (Ft (d, "entrée"), Bt), h = 0; tandis que (o = d [h ++]) if ((! r || -1 === x.inArray (o , r)) && (a = x.contains (o.ownerDocument, o), s = Ft (f.appendChild (o), "script"), un && _ t (s), n)) {i = 0; o = s [i ++]) kt.test (o.type || "") && n.push (o)} return s = null, f}, cleanData: fonction (e, t) {var n, r, o, a, s = 0, l = x.expando, u = x.cache, c = x.support.deleteExpando, f = x.événement.spécial; pour (; null! = (n = e [s]); s ++ ) si ((t || x.acceptData (n)) && (o = n [l], a = o && [o])) {if (a.events) pour (r dans a.events) f [r]? x.event.remove (n, r): x.removeEvent (n, r, a.handle);
u [o] && (supprimer u [o], c? supprimer n [l]: type de n.removeAttribute! == i? n.removeAttribute (l): n [l] = null, p.push (o)) }}, _ evalUrl: function (e) {return x.ajax ({url: e, tapez: "GET", dataType: "script", async:! 1, global:! 1, "throws":! 0}) }}), x.fn.extend ({wrapAll: function (e) {if (x.isFonction (e)) renvoie this.each (fonction (t) {x (this) .wrapAll (e.call (ceci, t))}); if (this [0]) {var t = x (e, ce [0] .ownerDocument) .eq (0) .clone (! 0); this [0] .parentNode && t.insertBefore (this [0]), t.map (fonction () {var e = this; while (e.firstChild && 1 === e.firstChild.nodeType) e = e.firstChild; return e}). Append (this)} renvoie cette }, wrapInner: function (e) {return x.isFonction (e)? this.each (fonction (t) {x (this) .wrapInner (e.call (this, t))}): this.each (fonction () {var t = x (ce), n = t.contents (); n.length? n.wrapAll (e): t.append (e)})}, wrap: fonction (e) {var t = x.isFonction (e), renvoyez ceci.each (function (n) {x (this) .wrapAll (t? e.call (this, n): e)})}, unwrap: function () {retourne this.parent (). each (function () { x.nodeName (this, "body") || x (this) .réplaceWith (this.childNodes)}). end ()}}; var Pt, Rt, Wt, $ t = / alpha \ ([^) ] * \) / i, It = / opacité \ s * = \ s * ([^)] *) /, zt = / ^ (haut | droite | bas | gauche) $ /, Xt = / ^ (aucun | table (?! - c [ea]). +) /, Ut = / ^ marge /, Vt = RegExp ("^ (" + w + ") (. *) $", "i"), Yt = RegExp ( "^ (" + w + ") (?! px) [az%] + $", "i"), Jt = RegExp ("^ ([+ -]) = (" + w + ")", "i" ), Gt = {BODY: "block"}, Qt = {position: "absolute", visibilité: "hidden", affichage: "block"}, Kt = {letterSpacing: 0, fontWvar Pt, Rt, Wt, $ t = / alpha \ ([^)] * \) / i, It = / opacité \ s * = \ s * ([^)] *) /, zt = / ^ (top | right | bottom | left) $ /, Xt = / ^ (aucun | table (?! - c [ea]). +) /, Ut = / ^ marge /, Vt = RegExp ("^ (" + w + " ) (. *) $ "," i "), Yt = RegExp (" ^ ("+ w +") (?! px) [az%] + $ "," i "), Jt = RegExp (" ^ ( [+ -]) = ("+ w +") "," i "), Gt = {BODY:" block "}, Qt = {position:" absolute ", visibilité:" hidden ", affichage:" block "} , Kt = {letterSpacing: 0, fontWvar Pt, Rt, Wt, $ t = / alpha \ ([^)] * \) / i, It = / opacité \ s * = \ s * ([^)] *) /, zt = / ^ (top | right | bottom | left) $ /, Xt = / ^ (aucun | table (?! - c [ea]). +) /, Ut = / ^ marge /, Vt = RegExp ("^ (" + w + " ) (. *) $ "," i "), Yt = RegExp (" ^ ("+ w +") (?! px) [az%] + $ "," i "), Jt = RegExp (" ^ ( [+ -]) = ("+ w +") "," i "), Gt = {BODY:" block "}, Qt = {position:" absolute ", visibilité:" hidden ", affichage:" block "} , Kt = {letterSpacing: 0, fontWabsolu ", visibilité:" caché ", affichage:" bloc "}, Kt = {letterSpacing: 0, fontWabsolu ", visibilité:" caché ", affichage:" bloc "}, Kt = {letterSpacing: 0, fontWhuit: 400}, Zt = ["Haut", "Droite", "Bas", "Gauche"], en = ["Webkit", "O", "Moz", "ms"], la fonction tn (e, t) {if (t dans e) renvoie t; var n = t.charAt (0) .toUpperCase () + t.slice (1), r = t, i = en.length; tandis que (i -) (t = en [i] + n, t en e) return t, return r} fonction nn (e, t) {return e = t || e, "none" === x.css (e, "affichage ") ||! x.contains (e.ownerDocument, e)} fonction rn (e, t) {var n, r, i, o = [], a = 0, s = e.length; pour (; s > a; a ++) r = e [a], r.style && (o [a] = x._data (r, "ancien affichage"), n = r.style.display, t? (o [a] || " none "! == n || (r.style.display =" ")," "=== r.style.display && nn (r) && (o [a] = x._data (r," olddisplay ", ln (r.nodeName)))): o [a] || (i = nn (r), (n && "aucun"! == n ||! i) && x._data (r, "olddisplay", i? n : x.css (r, "affichage"))));pour (a = 0; s> a; a ++) r = e [a], r.style && (t && "aucun"! == r.style.display && ""! == r.style.display || (r. style.display = t? o [a] || "": "none")); return e} x.fn.extend ({css: fonction (e, n) {retourne x.access (cette fonction (e , n, r) {var i, o, a = {}, s = 0; si (x.isArray (n)) {pour (o = Rt (e), i = n.longueur; i> s; s ++ ) a [n [s]] = x.css (e, n [s],! 1, o); renvoie a} renvoie r! == t? x.style (e, n, r): x.css (e, n)}, e, n, arguments.length> 1)}, afficher: function () {return rn (ceci,! 0)}, masquer: function () {return rn (this)}, bascule: function (e) {return "booléen" == typeof e? e? this.show (): this.hide (): this.each (function () {nn (this)? x (this) .show (): x (this) .hide ()})}}), x.extend ({cssHooks: {opacité: {get: fonction (e, t) {if (t) {var n = Wt (e, "opacité") ; return "" === n "" 1 ": n}}}}, cssNumber: {columnCount:! 0, fillOpacity:! 0, fontWeight:! 0, lineHauteur:! 0, opacité:! 0,ordre:! 0, orphelins:! 0, veuves:! 0, zIndex:! 0, zoom:! 0}, cssProps: {"float": x.support.cssFloat? "cssFloat": "styleFloat"}, style: fonction (e, n, r, i) {if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var o, a, s, l = x.camelCase (n), u = e. style: if (n = x.cssProps [l] || (x.cssProps [l] = tn (u, l)), s = x.cssHooks [n] || x.cssHooks [l], r == = t) retourner s && "get" dans s && (o = s.get (e,! 1, i))! == t? o: u [n]; si (a = typeof r, "chaîne" === a && (o = Jt.exec (r)) && (r = (o [1] +1) * o [2] + parseFloat (x.css (e, n)), a = "nombre"),! ( null == r || "nombre" === a && isNaN (r) || ("nombre"! == a || x.cssNumber [l] || (r + = "px"), x.support.clearCloneStyle | | ""! == r || 0! == n.indexOf ("background") || (u [n] = "hériter"), s && "set" dans s && (r = s.set (e, r ,i)) === t))) try {u [n] = r} catch (c) {}}}, css: fonction (e, n, r, i) {var o, a, s, l = x.camelCase (n); return n = x.cssProps [l] || (x.cssProps [l] = tn (e.style, l)), s = x.cssHooks [n] || x.cssHooks [ l], s && "get" dans s && (a = s.get (e,! 0, r)), a === t && (a = Wt (e, n, i)), "normal" === a && n dans Kt && (a = Kt [n]), "" === r || r? (o = parseFloat (a), r ===! 0 || x.isNumérique (o)? o || 0: a ): a}}), e.getComputedStyle? (Rt = fonction (t) {retourne e.getComputedStyle (t, null)}, Wt = fonction (e, n, r) {var i, o, a, s = r || Rt (e), l = s? s.getPropertyValue (n) || s [n]: t, u = e.style; return s && (""!! == l || x.contains (e. ownerDocument, e) || (l = x.style (e, n)), Yt.test (l) && Ut.test (n) && (i = u.largeur, o = u.minWidth, a = u.maxWidth , u.minWidth = u.maxWidth = u.width = l, l = s.width, u.width = i, u.minWidth = o, u.maxWidth = a)), l}): a.documentElement.currentStyle && (Rt = fonction (e) {return e.currentStyle}, Wt = fonction (e, n, r) {var i, o, a, s = r || Rt (e), l = s? s [n]: t, u = e.style; return null == l && u && u [n] && (l = u [n]), Yt.test (l) &&! zt.test (n) && (i = u.left, o = e.runtimeStyle, a = o && o.left, a && (o.left = e.currentStyle.left), u.left = "policeSize" === n "" 1em ": l, l = u.pixelLeft +" px ", u.left = i, a && (o. left = a)), "" === l "" auto ": l}); fonction sur (e, t, n) {var r = Vt.exec (t); return r? Math.max (0, r [1] - (n || 0)) + (r [2] || "px"): t} fonction an (e, t, n, r, i) {var o = n === (r ? "border": "content")? 4: "largeur" ​​=== t 1: 0, a = 0; pour (; 4> o; o + = 2) "marge" === n && (a + = x .css (e, n + Zt [o],! 0, i)), r? ("content" === n && (a- = x.css (e, "padding" + Zt [o],! 0 , i)), "marge"! == n && (a- = x.css (e, "bordure" + Zt [o] + "Largeur",! 0,i))) :( a + = x.css (e, "remplissage" + Zt [o],! 0, i), "remplissage"! == n && (a + = x.css (e, "bordure" + Zt [o] + "Largeur",! 0, i))); return a} fonction sn (e, t, n) {var r =! 0, i = "largeur" ​​=== t.offsetWidth: e .offsetHeight, o = Rt (e), a = x.support.boxSizing && "border-box" === x.css (e, "boxSizing",! 1, o); if (0> = i || null == i) {if (i = Wt (e, t, o), (0> i || null == i) && (i = e.style [t]), Yt.test (i)) retour i ; r = a && (x.support.boxSizingReliable || i === e.style [t]), i = parseFloat (i) || 0} renvoie i + an (e, t, n || (a? " border ":" content "), r, o) +" px "} fonction ln (e) {var t = a, n = Gt [e]; renvoyer n || (n = un (e, t)," none "! == n && n || (Pt = (Pt || x (" <iframe frameborder = '0' width = '0' height = '0' /> "). css (" cssText "," affichage: bloc ! important ")). appendTo (t.documentElement), t = (Pt [0] .contentWindow || Pt [0] .contentDocument) .document, t.write ("<! doctype html> <html> <corps>"), t.close (), n = un (e, t), Pt.detach ()), Gt [e] = n), n} fonction un (e, t) {var n = x (t.createElement (e)). appendTo (t. body), r = x.css (n [0], "affichage"); return n.remove (), r} x.each (["height", "width"], fonction (e, n) {x .cssHooks [n] = {get: fonction (e, r, i) {return r? 0 === e.offsetWidth && Xt.test (x.css (e, "affichage"))? x.swap (e, Qt , function () {return sn (e, n, i)}): sn (e, n, i): t}, ensemble: function (e, t, r) {var i = r && Rt (e); (e, t, r? an (e, n, r, x.support.boxSizing && "border-box" === x.css (e, "boxSize",! 1, i), i): 0)} }}), x.support.opacity || (x.cssHooks.opacity = {obtenir: function (e, t) {return It.test ((t && e.currentStyle? e.currentStyle.filter: e.style.filter) || "") ?.01 * parseFloat (RegExp. $ 1) + "": t? "1": ""}, ensemble: fonction (e, t) {var n = e.style, r = e.currentStyle, i = x.isNumeric ( t)? "alpha (opacité =" + 100 * t + ")": "", o = r && r.filter || n.filter || ""; n.zoom = 1, (t> = 1 || "" === t) && "" === x.trim (o.replace ($ t, "")) && n.removeAttribute && (n.removeAttribute ("filtre"), "" === t || r &&! r .filter) || (n.filter = $ t.test (o)? o.replace ($ t, i): o + "" + i)}}), x (function () {x.support.reliableMarginRight | | (x.cssHooks.marginRight = {get: fonction (e, n) {return n? x.swap (e, {affichage: "inline-block"}, Wt, [e, "marginRight"]): t} }),! x.support.pixelPosition && x.fn.position && x.each (["haut", "gauche"], fonction (e, n) {x.cssHooks [n] = {get: function (e, r) { retourne r? (r = Wt (e, n), Yt.test (r)? x (e) .position () [n] + "px": r): t}}})}), x.expr && x.expr.filters && (x.expr.filters.hidden = fonction ( e) {return 0> = e.offsetWidth && 0> = e.offsetHeight ||! x.support.reliableHiddenOffsets && "aucun" === (e.style && e.style.display || x.css (e, "affichage")) }, x.expr.filters.visible = function (e) {return! x.expr.filters.hidden (e)}), x.each ({margin: "", remplissage: "", border: "Largeur" }, fonction (e, t) {x.cssHooks [e + t] = {expand: fonction (n) {var r = 0, i = {}, o = "chaîne" == typeof n? n.split ( ""): [n]; pour (; 4> r; r ++) i [e + Zt [r] + t] = o [r] || o [r-2] || o [0]; }}, Ut.test (e) || (x.cssHooks [e + t] .set = on)}); var cn = /% 20 / g, pn = / \ [\] $ /, fn = / \ r? \ n / g, dn = / ^ (?: soumettre | bouton | image | réinitialiser | fichier) $ / i, hn = / ^ (?: entrée | sélectionner | textarea | keygen) /i;x.fn .extend ({serialize: function () {retourne x.param (this.serializeArray ())}, serializeArray: function () {retourne this.map (fonction () {var e = x.prop (ceci, "elements"); retourne e? x.makeArray (e): this}). filter (function () {var e = this.type; renvoie this.name &&! x (this) .is (": désactivé") && hn.test (this.nodeName) &&! dn.test (e) && (this.checked ||! Ct.test (e))}). Map (fonction (e, t)) {var n = x (this) .val (); renvoie null == n? Null: x.isArray (n)? X .map (n, function (e) {return {nom: t.name, valeur: e.replace (fn, "\ r \ n")}}): {nom: t.name, valeur: n.replace ( fn, "\ r \ n")}}). get ()}}, x.param = fonction (e, n) {var r, i = [], o = fonction (e, t) {t = x.isFonction (t)? t (): null == t? "": t, i [i.length] = encoderURIComponent (e) + "=" + encoderURIComponent (t)}; if (n === t && (n = x.ajaxSettings && x.ajaxSettings.traditional), x.isArray (e) || e.jquery &&! x.isPlainObject (e)) x.each (e, function () {o (this.name, this.value)}); else pour (r dans e) gn (r, e [r], n, o); return i.join ("&"). replace (cn, "+")}; fonction gn (e, t, n, r) {var i; si (x.isArray (t)) x.each (t, fonction (t, i) {n || pn.test (e)? r (e , i): gn (e + "[" + ("objet" == typeof i? t: "") + "]", i, n, r)}); sinon if (n || "object"! = = x.type (t)) r (e, t); sinon pour (i dans t) gn (e + "[" + i + "]", t [i], n, r)} x.each ("flou focus focus focus focus redimensionner décharger cliquer dblclick mousedown mouseup souris mouseover mouseout mouseenter mouseleave modification sélectionner soumettre keydown keypress keyup erreur contextmenu ".split (" "), fonction (e, t) {x.fn [t] = fonction (e, n) {return arguments.length> 0? this.on (t, null, e, n): this.trigger (t)}}), x.fn.extend ({hover: function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}, bind: fonction (e, t, n) {return this.on (e, null,t, n)}, unbind: function (e, t) {renvoyer this.off (e, null, t)}, delegate: fonction (e, t, n, r) {renvoyer this.on (t, e, n, r)}, undelegate: fonction (e, t, n) {return 1 === arguments.length? ce.off (e, "**"): this.off (t, e || "** ", n)}}); var mn, yn, vn = x.now (), bn = / \? /, xn = / #. * $ /, wn = / ([? &]) _ = [^ &] * /, Tn = / ^ (. *?): [\ T] * ([^ \ r \ n] *) \ r? $ / Gm, Cn = / ^ (?: à propos de | app | app- stockage |. + - extension | fichier | res | widget): $ /, Nn = / ^ (?: GET | HEAD) $ /, kn = / ^ \ / \ //, En = / ^ ([\ w. + -] +:) (?: \ / \ / ([^ \ /? #:] *) (? :: (\ d +) |) |) /, Sn = x.fn.load, An = {} , jn = {}, Dn = "* /". concat ("*"); try {yn = o.href} attrape (Ln) {yn = a.createElement ("a"), yn.href = "" , yn = yn.href} mn = En.exec (yn.toLongueCase ()) || []; fonction Hn (e) {fonction de retour (t, n) {"chaîne"! = typeof t && (n = t, t = "*"); var r, i = 0, o = t.àLongueurCase (). match (T) || []; if (x.isFonction (n)) tandis que (r = o [i ++]) " + "=== r [0]? (r = r.tranche (1) || "*", (e [r] = e [r] || []). unshift (n)) :( e [r] = e [r] || []). pousser ( n)}} fonction qn (e, n, r, i) {var o = {}, a = e === jn; fonction s (l) {var u; return o [l] =! 0, x. chaque (e [l] || [], fonction (e, l) {var c = l (n, r, i); return "chaîne"! = typeof c || a || o [c]? a? ! (u = c): t: (n.dataTypes.unshift (c), s (c),! 1)}), u} return s (n.dataTypes [0]) ||! o ["*" ] && s ("*")} fonction _n (e, n) {var r, i, o = x.ajaxSettings.flatOptions || {}; pour (i dans n) n [i]! == t && ((o [i]? e: r || (r = {})) [i] = n [i]); return r && x.extend (! 0, e, r), e} x.fn.load = fonction (e , n, r) {if ("chaîne"! = typeof e && Sn) retourne Sn.apply (ceci, arguments); var i, o, a, s = ceci, l = e.indexOf (""), retourne l> = 0 && (i = e.slice (l, e.length), e = e.slice (0, l)), x.isFonction (n)? (R = n, n = t): n && "object" = = typeof n && (a = "POST"), s.length> 0 && x.ajax ({url: e, tapez: a,dataType: "html", data: n}). done (fonction (e) {o = arguments, s.html (i? x ("<div>"). append (x.parseHTML (e)). find ( i): e)}). complete (r && function (e, t) {s.each (r, o || [e.responseText, t, e])}), ceci}, x.each (["ajaxStart" , "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], fonction (e, t) {x.fn [t] = fonction (e) {return this.on (t, e) }}), x.extend ({actif: 0, lastModified: {}, etag: {}, ajaxSettings: {url: yn, tapez: "GET", isLocal: Cn.test (mn [1]), global: ! 0, processData:! 0, async:! 0, contentType: "application / x-www-format-urlencoded; charset = UTF-8", accepte: {"*": Dn, texte: "text / plain", html: "text / html", xml: "application / xml, text / xml", json: "application / json, texte / javascript", contenu: {xml: / xml /, html: / html /, json: / json /},responseFields: {xml: "responseXML", texte: "responseText", json: "responseJSON"}, convertisseurs: {"* text": Chaîne, "text html":! 0, "text json": x.parseJSON, " text xml ": x.parseXML", flatOptions: {url:! 0, contexte:! 0}}, ajaxSetup: fonction (e, t) {return t? _n (_n (e, x.ajaxSettings), t): _n (x.ajaxSettings, e)}, ajaxPrefilter: Hn (An), ajaxTransport: Hn (jn), ajax: fonction (e, n) {"objet" == typeof e && (n = e, e = t), n = n || {}; var r, i, o, a, s, l, u, c, p = x.ajaxSetup ({}, n), f = p.context || p, d = p. context && (f.nodeType || f.jquery)? x (f): x.événement, h = x.Deferred (), g = x.Callbacks ("une fois la mémoire"), m = p.statusCode || {} , y = {}, v = {}, b = 0, w = "annulé", C = {readyState: 0, getResponseHeader: fonction (e) {var t; if (2 === b) {if (! c) {c = {}; while (t = Tn.exec (a)) c [t [1]. àLongueCase ()] = t [2]} t = c [e.toLongueCase ()]} return null = = t? null: t},getAllResponseHeaders: function () {return 2 === b? a: null}, setRequestHeader: fonction (e, t) {var n = e.toLocalCase (); renvoie b || (e = v [n] = v [ n] || e, y [e] = t), this}, overrideMimeType: fonction (e) {return b || (p.mimeType = e), ceci}, statusCode: function (e) {var t; (e) si (2> b) pour (t dans e) m [t] = [m [t], e [t]], sinon C.always (e [C.statut]), retourner ceci}, abandonner : function (e) {var t = e || w; retourne u && abort (t), k (0, t), ceci}}; if (h.promise (C) .complete = g.add, C. succès = C.done, C.error = C.fail, p.url = ((e || p.url || yn) + ""). replace (xn, ""). replace (kn, mn [1 ] + "//"), p.type = n.méthode || n.type || p.méthode || p.type, p.dataTypes = x.trim (p.dataType || "*"). toLowerCase () .match (T) || [""], null == p.crossDomain && (r = En.exec (p.url.toLowerCase ()), p.crossDomain =! (! r || r [1] === mn [1] && r [2] === mn [2] && (r [3] || ("http:" === r [1]? "80": "443 ")) === (mn [3] || (" http: "=== mn [1]?" 80 ":" 443 ")))), p.data && p.processData &&" chaîne "! = Typeof p.data && (p.data = x.param (p.data, p.traditional)), qn (An, p, n, C), 2 === b) renvoie C; l = p.global, l && 0 = == x.active ++ && x.event.trigger ("ajaxStart"), p.type = p.type.àUpperCase (), p.hasContent =! Nn.test (p.type), o = p.url, p.hasContent || (p.data && (o = p.url + = (bn.test (o)? "&": "?") + p.data, supprimer p.data), p.cache ===! 1 && (p.url = wn.test (o)? O.replace (wn, "$ 1 _ =" + vn ++): o + (bn.test (o)? "&": "?") + "_ =" + vn ++)), p.ifModified && (x.lastModified [o] && C.setRequestHeader ("Si-Modifié-Depuis", x.lastModifié [o]), x.etag [o] && C.setRequestHeader ("Si-Aucun- Match ", x.etag [o])), (p.data && p.hasContent && p.contentType! ==! 1 || n.contentType) && C.setRequestHeader ("Content-Type", p.contentType), C.setRequestHeader ("Accepter", p.dataTypes [0] && p.accepts [p.dataTypes [0]]? P.accepts [p.dataTypes [0]] + ("*"! == p.dataTypes [0]? "," + Dn + "; q = 0.01": ""): p.accepts ["*"]); pour (i dans p.headers) C.setRequestHeader (i, p.headers [i]); si (p.beforeSend && (p.beforeSend.call (f, C, p) === ! 1 || 2 === b)) retourne C.abort (); w = "abort"; pour (i dans {succès: 1, erreur: 1, complète: 1}) C [i] (p [i ]), si (u = qn (jn, p, n, C)) {C.readyState = 1, l && d.trigger ("ajaxSend", [C, p]), p.async && p.timeout> 0 && (s = setTimeout (function () {C.abort ("timeout")}, p.timeout)); try {b = 1, fin (y, k)} catch (N) {if (! (2> b) ) jeter N; k (-1, N)}} autre k (-1, "aucun transport"); fonction k (e, n, r,i) {var c, y, v, w, T, n = n; 2! == b && (b = 2, s && clearTimeout (s), u = t, a = i || "", C.readyState = e > 0? 4: 0, c = e> = 200 && 300> e || 304 === e, r && (w = Mn (p, C, r)), w = On (p, w, C, c), c? (p.ifModified && (T = C.getResponseHeader ("Dernière modification"), T && (x.lastModified [o] = T), T = C.getResponseHeader ("etag"), T && (x.etag [o ] = T)), 204 === e "" HEAD "=== p.type? N =" nocontent ": 304 === e? N =" non modifié ":( N = w.state, y = w.data, v = w.erreur, c =! v)) :( v = N, (e ||! N) && (N = "erreur", 0> e && (e = 0)), C. status = e, C.statusText = (n || N) + "", c? h.résolveWith (f, [y, N, C]): h.rejet avec (f, [C, N, v]), C.statusCode (m), m = t, l && d.trigger (c "" ajaxSuccess ":" ajaxError ", [C, p, c: y: v]), g.fireWith (f, [C, N]) , l && (d.trigger ("ajaxComplete", [C, p]), - x.active || x.event.trigger ("ajaxStop"))} return C}, getJSON: fonction (e, t, n) {return x.get (e, t, n, "json")}, getScript: function (e, n) { return x.get (e, t, n, "script")}}), x.each (["get", "post"], fonction (e, n) {x [n] = fonction (e, r , i, o) {return x.isFonction (r) && (o = o || i, i = r, r = t), x.ajax ({url: e, tapez: n, dataType: o, data: r, succès: i})}}), la fonction Mn (e, n, r) {var i, o, a, s, l = e.contents, u = e.dataTypes; while ("*" === [0]) u.shift (), o === t && (o = e.mimeType || n.getResponseHeader ("Content-Type")); si (o) pour (s dans l) if (l [ s] && l [s] .test (o)) {u.unshift (s); break} if (u [0] dans r) a = u [0]; else {for (s dans r) {if (! u [0] || e.convertisseurs [s + "" + u [0]]) {a = s; rompre} i || (i = s)} a = a || i} retourner un? (a! = = u [0] && u.unshift (a), r [a]): t} fonction On (e, t, n, r) {var i, o, a, s, l, u = {}, c = e.dataTypes.slice (); if (c [1]) pour (a dans e.converters) u [a.toLowerCase ()] = e.convertisseurs [a]; o = c.shift (); tandis que (o) if (e.responseFields [o] && (n [e.responseFields [o]] = t),! l && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), l = o, o = c.shift ()) if ("*" === o) o = l; sinon if ("*"! == l && l! == o) {if (a = u [l + "" + o] || u ["*" + o],! a) pour (i dans u) if (s = i.split (""), s [1] = == o && (a = u [l + "" + s [0]] || u ["*" + s [0]])) {a ===! 0? a = u [i]: u [i ]! ==! 0 && (o = s [0], c.unshift (s [1])); break} si (a! ==! 0) if (a && e ["jette"]) t = a (t ); sinon, essayez {t = a (t)} catch (p) {return {état: "parsererreur", erreur: a? ​​p: "Aucune conversion de" + l + "à" + o}}} return {state: "succès", données: t}} x.ajaxSetup ({accepte: {script: "texte / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, contenu: {script: / (?:java | ecma) script /}, convertisseurs: {"script de texte": function (e) {return x.globalEval (e), e}}}), x.ajaxPrefilter ("script", fonction (e) {e. cache === t && (e.cache =! 1), e.crossDomain && (e.type = "GET", e.global =! 1)}), x.ajaxTransport ("script", fonction (e) {si (e.crossDomain) {var n, r = un.head || x ("head") [0] || un.documentElement; return {envoyer: fonction (t, i) {n = a.createElement ("script "), n.async =! 0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = fonction (e, t) {(t || ! n.readyState || / loaded | complete / .test (n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild (n), n = null, t || i (200, "succès"))}, r.insertBefore (n, r.firstChild)}, abandonner: function () {n && n.onload (t,! 0)}}}}); var Fn = [], Bn = / (=) \? (? = & | $) | \? \? /; x.ajaxSetup ({jsonp: "callback", jsonpCallback: function () {var e = Fn.pop () || x.expando + "_" + vn ++; retourne ceci [e] =! 0, e}}), x. ajaxPrefilter ("json jsonp", fonction (n, r, i) {var o, a, s, l = n.jsonp! ==! 1 && (Bn.test (n.url)? "url": "chaîne" == typeof n.data &&! (n.contentType || ""). indexOf ("application / x-www-format-urlencoded") && Bn.test (n.data) && "data"); return l || " jsonp "=== n.dataTypes [0]? (o = n.jsonpCallback = x.isFonction (n.jsonpCallback)? n.jsonpCallback (): n.jsonpCallback, l? n [l] = n [l]. remplacer (Bn, "$ 1" + o): n.jsonp! ==! 1 && (n.url + = (bn.test (n.url)? "&": "?") + n.jsonp + "=" + o), n.converters ["script json"] = fonction () {return s || x.erreur (o + "n'a pas été appelé"), s [0]}, n.dataTypes [0] = "json", a = e [o],e [o] = fonction () {s = arguments}, i.always (fonction () {e [o] = a, n [o] && (n.jsonpCallback = r.jsonpCallback, Fn.push (o)) , s && x.isFonction (a) && a (s [0]), s = a = t}), "script"): t}); var Pn, Rn, Wn = 0, $ n = e.ActiveXObject && function () { var e; for (e dans Pn) Pn [e] (t,! 0)}; fonction In () {try {return nouveau e.XMLHttpRequest} catch (t) {}} fonction zn () {try {return new e.ActiveXObject ("Microsoft.XMLHTTP")} catch (t) {}} x.ajaxSettings.xhr = e.ActiveXObject? function () {renvoyer this.isLocal && In () || zn ()}: In, Rn = x.ajaxSettings.xhr (), x.support.cors = !! Rn && "avecCredentials" dans Rn, Rn = x.support.ajax = !! Rn, Rn && x.ajaxTransport (fonction (n) {if (! n.crossDomain || x.support.cors) {var r; return {envoyer: fonction (i, o) {var a, s, l = n.xhr (); if (n.nom d'utilisateur? l.open (n.type, n.url, n.async, n.username, n.password): l.open (n.type, n.url, n.async), n.xhrFields) pour (s dans n.xhrFields) l [s] = n.xhrFields [s]; n.mimeType && l.overrideMimeType && l.overrideMimeType (n.mimeType), n.crossDomain || i ["X-Requested-With"] || (i ["X-Requested-Avec"] = "XMLHttpRequest"); try {pour (s dans i) l.setRequestHeader (s, i [s])} catch (u) {} l.send (n .hasContent && n.data || null), r = fonction (e, i) {var s, u, c, p, essayez {if (r && (i || 4 === l.readyState)) if (r = t , a && (l.onreadystatechange = x.noop, $ n && supprimer Pn [a]), i) 4! == l.readyState && l.abort (); sinon {p = {}, s = l.status, u = l. getAllResponseHeaders (), "string" == typeof l.responseText && (p.text = l.responseText); essayez {c = l.statusText} catch (f) {c = ""} s ||! n.isLocal || n.crossDomain? 1223 === s && (s = 204): s = p.text? 200: 404}} catch (d) {i || o (-1, d)} p && o (s, c, p, u)}, n.async? 4 === l.readyState? setTimeout (r) :( a = ++ Wn, $ n &&(Pn || (Pn = {}, x (e) .unload ($ n)), Pn [a] = r), l.onreadystatechange = r): r ()}, abandonner: function () {r && r ( t,! 0)}}}}); var Xn, Un, Vn = / ^ (?: bascule | afficher | masquer) $ /, Yn = RegExp ("^ (?: ([+ -]) = |) ("+ w +") ([az%] *) $ "," i "), Jn = / queueHooks $ /, Gn = [nr], Qn = {" * ": [fonction (e, t) {var n = this.createTween (e, t), r = n.cur (), i = Yn.exec (t), o = i && i [3] || (x.cssNumber [e]? "": "px" ), a = (x.cssNombre [e] || "px"! == o && + r) && Yn.exec (x.css (n.elem, e)), s = 1, l = 20; si (a && a [3]! == o) {o = o || a [3], i = i || [], a = + r || 1; faire s = s || ".5", a / = s , x.style (n.elem, e, a + o), tandis que (s! == (s = n.cur () / r) && 1! == s && - l)} return i && (a = n. début = + a || + r || 0, n.unité = o, n.fin = i [1]? a + (i [1] +1) * i [2]: + i [2]), n }]}; function Kn () {return setTimeout (fonction () {Xn = t}), Xn = x.now ()} fonction Zn (e, t, n) {var r, i = (Qn [t] || []). concat (Qn ["*"]),o = 0, a = i.length; pour (; a> o; o ++) si (r = i [o] .call (n, t, e)) renvoie r} fonction er (e, t, n) { var r, i, o = 0, a = Gn.length, s = x.Deferred (). always (fonction () {delete l.elem}), l = fonction () {if (i) renvoie! 1; var t = Xn || Kn (), n = Math.max (0, u.startTime + u.durée-t), r = n / u.duration || 0, o = 1-r, a = 0, l = u.tweens.length; pour (; l> a; a ++) u.tweens [a] .run (o); return s.notifyWith (e, [u, o, n]), 1> o && l? n : (s.résolveWith (e, [u]),! 1)}, u = s.promise ({elem: e, props: x.extend ({}, t), opts: x.extend (! 0, {specialEasing: {}}, n), originProperties: t, originalOptions: n, startTime: Xn || Kn (), durée: n.duration, tweens: [], createTween: fonction (t, n) {var r = x.Tween (e, u.opts, t, n, u.opts.specialEasing [t] || u.opts.easing); return u.tweens.push (r), r}, stop: fonction (t) {var n = 0, r = t? u.tweens.length: 0; si (i) renvoie ceci; pour (i =! 0; r> n; n ++) u.tweens [n] .run (1); retourner t? s.résolveWith (e, [u, t]): s.rejectWith (e, [u, t]), ceci}}), c = u.props;pour (tr (c, u.opts.specialEasing); a> o; o ++) si (r = Gn [o] .call (u, e, c, u.opts)) renvoie r, renvoie x.map (c , Zn, u), x.isFonction (u.opts.start) && u.opts.start.call (e, u), x.fx.timer (x.extend (l, {elem: e, anim: u, queue: u.opts.queue})), u.progress (u.opts.progress) .done (u.opts.done, u.opts.complete) .fail (u.opts.fail) .always (u. opts.always)} fonction tr (e, t) {var n, r, i, o, a; pour (n dans e) si (r = x.camelCase (n), i = t [r], o = e [n], x.isArray (o) && (i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, supprimer e [n ]), a = x.cssHooks [r], un && "expand" dans a) {o = a.expand (o), supprime e [r]; pour (n dans o) n dans e || (e [n ] = o [n], t [n] = i)} autre t [r] = i} x.Animation = x.extend (er, {tweener: fonction (e, t) {x.isFonction (e)? (t = e, e = ["*"]): e = e.split (""); var n, r = 0, i = e.length; pour (; i> r; r ++) n = e [ r], Qn [n] = Qn [n] || [], Qn [n] .unshift (t)}, préfiltre: fonction (e, t) {t? Gn.unshift (e): Gn.push ( e)}});fonction nr (e, t, n) {var r, i, o, a, s, l, u = ceci, c = {}, p = e.style, f = e.nodeType && nn (e), d = x ._data (e, "fxshow"); n.queue || (s = x._queueHooks (e, "fx"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function () {s.unqueued || l ()}), s.unqueued ++, u.always (function () {u.always (function () {s.unqueued -, x.queue (e, "fx"). longueur || s.empty.fire ()}))), 1 === e.nodeType && ("height" dans t || "largeur" ​​dans t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], "en ligne" === x.css (e, "affichage") && "none" === x.css (e, "float") && ( x.support.inlineBlockNeedsLayout && "inline"! == ln (nom.node)? p.zoom = 1: p.display = "inline-block")), n.overflow && (p.overflow = "caché", x. support.shrinkWrapBlocks || u.always (function () {p.overflow = n.débordement [0], p.overflowX = n.overflow [1], p.overflowY = n.overflow [2]})), pour (r dans t) si (i = t [r], Vn.exec (i )) {if (supprimer t [r], o = o || "bascule" === i, i === (f "cacher": "afficher")) continuer; c [r] = d && d [r ] || x.style (e, r)} if (! x.isEmptyObject (c)) {d? "caché" dans d && (f = d.hidden): d = x._data (e, "fxshow", {}), o && (d.hidden =! f), f? x (e) .show (): u.done (fonction () {x (e) .hide ()}), u.done (fonction ( ) {var t; x._removeData (e, "fxshow"); pour (t dans c) x.style (e, t, c [t])}); pour (r dans c) a = Zn (f? d [r]: 0, r, u), r dans d || (d [r] = a.start, f && (a.fin = a.start, a.start = "largeur" ​​=== r || "hauteur" === r? 1: 0))}} fonction rr (e, t, n, r, i) {return nouveau rr.prototype.init (e, t, n, r, i)} x. Tween = rr, rr.prototype = {constructeur: rr, init: fonction (e, t, n, r, i, o) {this.élément = e, this.prop = n, this.ayant = i || " swing ", this.options = t, this.start = ceci.now = this.cur (), this.end = r, this.unit = o || (x.cssNombre [n]? "": "px")}, cur: function () {var e = rr.propHooks [this.prop]; return e && e.get? e.get (this): rr.propHooks._default.get (this)}, exécutez: function (e) {var t, n = rr.propHooks [this.prop] ; return this.pos = t = this.options.duration? x.ayant [cette.procedure] (e, cette.option.duration * e, 0,1, cette.option.duration): e, this.now = (this.end-this.start) * t + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), n && n.set? n.set (this): rr.propHooks._default.set (this), this}}, rr.prototype.init.prototype = rr.prototype, rr.propHooks = {_ par défaut: {get: function (e) {var t; return null == e .elem [e.prop] || e.elem.style && null! = e.elem.style [e.prop]? (t = x.css (e.elem, e.prop, ""), t && "auto" ! == t? t: 0): e.elem [e.prop]}, set: fonction (e) {x.fx.step [e.prop]? x.fx.step [e.prop] (e): e.elem.style && (null! = e.elem.style [x.cssProps [e.prop]] || x.cssHooks [e.prop])? x.style (e.elem, e.prop, e.now + e.unit): e.elem [e.prop] = e.now}}}, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = {set: function (e) {e .elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}}, x.each (["bascule", "afficher", "masquer"], fonction (e, t) { var n = x.fn [t]; x.fn [t] = fonction (e, r, i) {return null == e || "booléen" == typeof e? n.apply (ceci, arguments): this.anime (ir (t,! 0), e, r, i)}}), x.fn.extend ({fadeTo: fonction (e, t, n, r) {return this.filter (nn). css ("opacité", 0) .show () .fin (). animate ({opacité: t}, e, n, r)}, anime: fonction (e, t, n, r) {var i = x .isEmptyObject (e), o = x.speed (t, n, r), a = fonction () {var t = er (cela, x.extend ({}, e), o); (i || x ._data (this, "finish")) && t.stop (! 0)}; retourne a.finish = a, je || o.queue ===! 1? this.each (a):this.queue (o.queue, a)}, stop: fonction (e, n, r) {var i = fonction (e) {var t = e.stop; supprimer e.stop, t (r)}; "string"! = typeof e && (r = n, n = e, e = t), n && e! ==! 1 && this.queue (e || "fx", []), this.each (fonction () {var t =! 0, n = null! = e && e + "queueHooks", o = x.timers, a = x._data (this); si (n) a [n] && a [n] .stop && i (a [n]) ; else pour (n dans a) un [n] && a [n] .stop && Jn.test (n) && i (a [n]); pour (n = o.length; n -;) o [n] .elem ! == this || null! = e && o [n] .queue! == e || (o [n] .anim.stop (r), t =! 1, o.splice (n, 1)); t ||! r) && x.dequeue (this, e)})}, fin: function (e) {return e! ==! 1 && (e = e || "fx"), this.each (function () {var t, n = x._data (ce), r = n [e + "queue"], i = n [e + "queueHooks"], o = x.timers, a = r? r.length: 0; (n.finish =! 0, x.queue (this, e, []), i && i.stop && i.stop.call (ceci,! 0), t = o.length; t -;) o [t] .elem === this && o [t] .queue === e && (o [t] .anim.stop (! 0), o.splice (t, 1)); pour (t = 0; a> t; t ++) r [t] && r [t] .finir && r [t] .finish.call (this); supprimer n.finir})}}); fonction ir (e, t) {var n, r = {hauteur: e}, i = 0, pour (t = t 1: 0; 4> i; i + = 2-t) n = Zt [i], r ["marge" + n ] = r ["padding" + n] = e; retourne t && (r.opacity = r.width = e), r} x.each ({slideDown: ir ("show"), slideUp: ir ("cacher" ), slideToggle: ir ("bascule"), fadeIn: {opacité: "show"}, fadeOut: {opacité: "hide"}, fadeToggle: {opacité: "bascule"}}, fonction (e, t) {x .fn [e] = fonction (e, n, r) {return this.anime (t, e, n, r)}}, x.speed = fonction (e, t, n) {var r = e && " objet "== typeof e? x.extend ({}, e): {complete: n ||! n && t || x.isFonction (e) && e, durée: e, easing: n && t || t &&! x.isFunction ( t) && t};return r.duration = x.fx.off? 0: "nombre" == typeof r.duration? r.duration: r.duration dans x.fx.speeds? x.fx.speeds [r.duration]: x. fx.speeds._default, (null == r.queue || r.queue ===! 0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () {x.isFunction (r.old) && r.old.call (this), r.queue && x.dequeue (this, r.queue)}, r}, x.easing = {linear: fonction (e) {return e} , swing: fonction (e) {return.5-Math.cos (e * Math.PI) / 2}}, x.timers = [], x.fx = rr.prototype.init, x.fx.tick = function () {var e, n = x.timers, r = 0; pour (Xn = x.now (); n.length> r; r ++) e = n [r], e () || n [r ]! == e || n.splice (r -, 1); n.length || x.fx.stop (), Xn = t}, x.fx.timer = fonction (e) {e () && x.timers.push (e) && x.fx.start ()}, x.fx.interval = 13, x.fx.start = fonction () {Un || (Un = setInterval (x.fx.tick, x .fx.interval))}, x.fx.stop = fonction () {clearInterval (Un), Un = null}, x.fx.speeds = {lent: 600, rapide: 200, _default:400}, x.fx.step = {}, x.expr && x.expr.filters && (x.expr.filters.animated = fonction (e) {return x.grep (x.timers, fonction (t) {return e = == t.elem}). length}), x.fn.offset = fonction (e) {if (arguments.length) renvoie e === t: this.each (fonction (t) {x.offset .setOffset (this, e, t)}); var n, r, o = {top: 0, à gauche: 0}, a = this [0], s = a && a.ownerDocument; if (s) renvoie n = s .documentElement, x.contains (n, a)? (typeof a.getBoundingClientRect! == i && (o = a.getBoundingClientRect ()), r = ou (s), {top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0), à gauche: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0)}): o}, x.offset = {setOffset : fonction (e, t, n) {var r = x.css (e, "position"); "statique" === r && (e.style.position = "relatif"); var i = x (e) , o = i.offset (), a = x.css (e, "top"), s = x.css (e, "gauche"), l = ("absolute" === r || "fixed"=== r) && x.inArray ("auto", [a, s])> - 1, u = {}, c = {}, p, f; l? (c = i.position (), p = c.top, f = c. gauche) :( p = parseFloat (a) || 0, f = parseFloat (s) || 0), x.isFonction (t) && (t = t.call (e, n , o)), null! = t.top && (u.top = t.top-o.top + p), null! = t.left && (u.left = t.left-o.left + f), " en utilisant "in t? t.using.call (e, u): i.css (u)}}, x.fn.extend ({position: function () {if (this [0]) {var e, t , n = {top: 0, left: 0}, r = this [0]; return "fixe" === x.css (r, "position")? t = r.getBoundingClientRect () :( e = this .offsetParent (), t = this.offset (), x.nodeName (e [0], "html") || (n = e.offset ()), n.top + = x.css (e [0] , "borderTopWidth",! 0), n = gauche + = x.css (e [0], "borderLeftWidth",! 0)), {top: t.top-n.top-x.css (r, "margeTop ",! 0), à gauche: t.left-n.left-x.css (r," margeLeft ",! 0)}}}, offsetParent: function () {return this.map (fonction () {var e = ceci.offsetParent || s; while (e &&! x.nodeName (e, "html") && "statique" === x.css (e, "position")) e = e.offsetParent; return e || s}) }}), x.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, fonction (e, n) {var r = / Y / .test (n); x.fn [e] = fonction ( i) {return x.access (this, fonction (e, i, o) {var a = ou (e); retourne o === t? a? n dans a? a [n]: a.document.documentElement [i]: e [i] :( a? a.scrollTo (r? x (a) .scrollLeft (): o, r? o: x (a) .scrollTop ()): e [i] = o, t)}, e, i, arguments.length, null)}}); function ou (e) {return x.isWindow (e)? e: 9 === e.nodeType? e.defaultView || e.parentWindow :! 1} x.each ({Hauteur: "height", Largeur: "width"}, fonction (e, n) {x.each ({remplissage: "interne" + e, contenu: n, "": " externe "+ e}, fonction (r, i) {x.fn [i] = fonction (i, o) {var a = arguments.length && (r ||" booléen "! = typeof i), s = r | | (i ===! 0 || o ===!0? "Margin": "border"); return x.access (this, fonction (n, r, i) {var o; renvoie x.isWindow (n)? N.document.documentElement ["client" + e] : 9 === n.nodeType? (O = n.documentElement, Math.max (n.body ["scroll" + e], o ["scroll" + e], n.body ["offset" + e] , o ["offset" + e], o ["client" + e])): i === t? x.css (n, r, s): x.style (n, r, i, s) }, n, a? i: t, a, null)}})}), x.fn.size = fonction () {return this.length}, x.fn.etSelf = x.fn.addBack, "objet "== typeof module && module &&" objet "== typeof module.exports? module.exports = x: (e.jQuery = e. $ = x," fonction "== typeof définir && define.amd && define (" jquery ", [], function () {return x}))}) (fenêtre);client "+ e]: 9 === n.nodeType? (o = n.documentElement, Math.max (n.body [" scroll "+ e], o [" scroll "+ e], n.body [" offset "+ e], o [" offset "+ e], o [" client "+ e])): i === t? x.css (n, r, s): x.style (n, r , i, s)}, n, a? i: t, a, null)}})}), x.fn.size = fonction () {return this.length}, x.fn.etSelf = x.fn .addBack, "objet" == typeof module && module && "objet" == typeof module.exports? module.exports = x: (e.jQuery = e. $ = x, "fonction" == typeof définir && define.amd && define ("jquery" , [], function () {return x}))}) (fenêtre);client "+ e]: 9 === n.nodeType? (o = n.documentElement, Math.max (n.body [" scroll "+ e], o [" scroll "+ e], n.body [" offset "+ e], o [" offset "+ e], o [" client "+ e])): i === t? x.css (n, r, s): x.style (n, r , i, s)}, n, a? i: t, a, null)}})}), x.fn.size = fonction () {return this.length}, x.fn.etSelf = x.fn .addBack, "objet" == typeof module && module && "objet" == typeof module.exports? module.exports = x: (e.jQuery = e. $ = x, "fonction" == typeof définir && define.amd && define ("jquery" , [], function () {return x}))}) (fenêtre);length}, x.fn.andSelf = x.fn.addBack, "objet" == typeof module && module && "objet" == typeof module.exports? module.exports = x: (e.jQuery = e. $ = x, " function "== typeof define && define.amd && define (" jquery ", [], function () {return x}))}) (fenêtre);length}, x.fn.andSelf = x.fn.addBack, "objet" == typeof module && module && "objet" == typeof module.exports? module.exports = x: (e.jQuery = e. $ = x, " function "== typeof define && define.amd && define (" jquery ", [], function () {return x}))}) (fenêtre);
